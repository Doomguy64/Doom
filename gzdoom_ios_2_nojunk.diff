From 72117f0677a3711bee71b26a996d0d702d61737b Mon Sep 17 00:00:00 2001
From: Emile Belanger <emile@Emiles-Mac-mini.local>
Date: Sun, 17 Jan 2016 16:18:59 +0000
Subject: [PATCH] IOS updates

---
 src/d_main.cpp                   |    7 +
 src/g_game.cpp                   |    8 +
 src/gl/scene/gl_scene.cpp        |    3 +-
 src/gl/system/gl_framebuffer.cpp |    1 +
 src/gl/system/gl_interface.cpp   |   10 +-
 src/gl/textures/gl_hwtexture.cpp |   42 +-
 src/mobile/game_interface.cpp    |  434 ++++++
 src/mobile/game_interface.h      |   45 +
 src/mobile/ios_interface.h       |   26 +
 src/mobile/ios_interface.m       |   21 +
 src/mobile/touch_interface.cpp   |  714 +++++++++
 src/mobile/touch_interface.h     |   17 +
 src/posix/sdl/i_main.cpp         |   15 +
 src/sound/fmodsound_studio.cpp   | 3050 ++++++++++++++++++++++++++++++++++++++
 src/sound/fmodsound_studio.h     |  137 ++
 src/v_video.cpp                  |    1 +
 16 files changed, 4522 insertions(+), 9 deletions(-)
 create mode 100755 src/mobile/game_interface.cpp
 create mode 100755 src/mobile/game_interface.h
 create mode 100644 src/mobile/ios_interface.h
 create mode 100644 src/mobile/ios_interface.m
 create mode 100755 src/mobile/touch_interface.cpp
 create mode 100644 src/mobile/touch_interface.h
 create mode 100755 src/sound/fmodsound_studio.cpp
 create mode 100755 src/sound/fmodsound_studio.h

diff --git a/src/d_main.cpp b/src/d_main.cpp
index 3b3cce1..a516af2 100644
--- a/src/d_main.cpp
+++ b/src/d_main.cpp
@@ -108,6 +108,10 @@
 #include "r_renderer.h"
 #include "p_local.h"
 
+#ifdef __MOBILE__
+#include "touch_interface.h"
+#endif
+
 EXTERN_CVAR(Bool, hud_althud)
 void DrawHUD();
 
@@ -2210,6 +2214,8 @@ void D_DoomMain (void)
 	int argcount;	
 	FIWadManager *iwad_man;
 
+
+    
 	// +logfile gets checked too late to catch the full startup log in the logfile so do some extra check for it here.
 	FString logfile = Args->TakeValue("+logfile");
 	if (logfile.IsNotEmpty())
@@ -2365,6 +2371,7 @@ void D_DoomMain (void)
 
 		Printf ("V_Init: allocate screen.\n");
 		V_Init (!!restart);
+        
 
 		// Base systems have been inited; enable cvar callbacks
 		FBaseCVar::EnableCallbacks ();
diff --git a/src/g_game.cpp b/src/g_game.cpp
index 8436738..4e73acd 100644
--- a/src/g_game.cpp
+++ b/src/g_game.cpp
@@ -523,6 +523,10 @@ static inline int joyint(double val)
 	}
 }
 
+#ifdef __MOBILE__
+extern void Mobile_IN_Move(ticcmd_t* cmd );
+#endif
+
 //
 // G_BuildTiccmd
 // Builds a ticcmd from all of the available inputs
@@ -686,6 +690,10 @@ void G_BuildTiccmd (ticcmd_t *cmd)
 		forward += (int)((float)mousey * m_forward);
 	}
 
+#ifdef __MOBILE__
+    Mobile_IN_Move(cmd);
+#endif
+    
 	cmd->ucmd.pitch = LocalViewPitch >> 16;
 
 	if (SendLand)
diff --git a/src/gl/scene/gl_scene.cpp b/src/gl/scene/gl_scene.cpp
index 7ba77ab..ede2f60 100644
--- a/src/gl/scene/gl_scene.cpp
+++ b/src/gl/scene/gl_scene.cpp
@@ -788,8 +788,9 @@ void FGLRenderer::EndDrawScene(sector_t * viewsector)
 	}
 
 	glDisable(GL_STENCIL_TEST);
+#ifndef USE_GLES
 	glDisable(GL_POLYGON_SMOOTH);
-
+#endif
 	framebuffer->Begin2D(false);
 
 	ResetViewport();
diff --git a/src/gl/system/gl_framebuffer.cpp b/src/gl/system/gl_framebuffer.cpp
index 238d9eb..2451cfa 100644
--- a/src/gl/system/gl_framebuffer.cpp
+++ b/src/gl/system/gl_framebuffer.cpp
@@ -144,6 +144,7 @@ void OpenGLFrameBuffer::InitializeState()
 	glEnable(GL_DITHER);
 	glEnable(GL_ALPHA_TEST);
 	glDisable(GL_CULL_FACE);
+
 	glDisable(GL_POLYGON_OFFSET_FILL);
 #ifndef USE_GLES
 	glEnable(GL_POLYGON_OFFSET_LINE);
diff --git a/src/gl/system/gl_interface.cpp b/src/gl/system/gl_interface.cpp
index 0e525c1..d6dd81d 100644
--- a/src/gl/system/gl_interface.cpp
+++ b/src/gl/system/gl_interface.cpp
@@ -237,7 +237,7 @@ void gl_SetTextureMode(int type)
 
 		glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_MODULATE); 
 		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_PRIMARY_COLOR);
-		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_TEXTURE0);
+		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_TEXTURE);
 		glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA, GL_SRC_ALPHA);
 		glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA, GL_SRC_ALPHA);
 	}
@@ -245,7 +245,7 @@ void gl_SetTextureMode(int type)
 	{
 		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE);
 		glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB, GL_MODULATE);
-		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_TEXTURE0);
+		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_TEXTURE);
 		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB, GL_PRIMARY_COLOR);
 		glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB, GL_SRC_COLOR);
 		glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB, GL_SRC_COLOR);
@@ -258,14 +258,14 @@ void gl_SetTextureMode(int type)
 	{
 		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE);
 		glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB, GL_MODULATE);
-		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_TEXTURE0);
+		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_TEXTURE);
 		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB, GL_PRIMARY_COLOR);
 		glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB, GL_ONE_MINUS_SRC_COLOR);
 		glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB, GL_SRC_COLOR);
 
 		glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_MODULATE); 
 		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_PRIMARY_COLOR);
-		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_TEXTURE0);
+		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_TEXTURE);
 		glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA, GL_SRC_ALPHA);
 		glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA, GL_SRC_ALPHA);
 	}
@@ -273,7 +273,7 @@ void gl_SetTextureMode(int type)
 	{
 		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE);
 		glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB, GL_MODULATE);
-		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_TEXTURE0);
+		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_TEXTURE);
 		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB, GL_PRIMARY_COLOR);
 		glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB, GL_ONE_MINUS_SRC_COLOR);
 		glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB, GL_SRC_COLOR);
diff --git a/src/gl/textures/gl_hwtexture.cpp b/src/gl/textures/gl_hwtexture.cpp
index c2fbc2b..8b947ba 100644
--- a/src/gl/textures/gl_hwtexture.cpp
+++ b/src/gl/textures/gl_hwtexture.cpp
@@ -71,10 +71,13 @@ unsigned int FHardwareTexture::lastbound[FHardwareTexture::MAX_TEXTURES];
 //===========================================================================
 int FHardwareTexture::GetTexDimension(int value)
 {
-#ifdef USE_GLES9
+#ifdef USE_GLES
     int i=1;
+    
     while (i<value) i+=i;
-    //if (i>2048) i = 2048; //Dont go above this size
+    
+    if (i>2048) i = 2048; //Dont go above this size on mobiles!
+    
     return i;
 #else
 	if (value > gl.max_texturesize) return gl.max_texturesize;
@@ -180,7 +183,7 @@ void FHardwareTexture::Resize(int width, int height, unsigned char *src_data, un
 	}
 }
 
-
+ extern "C" void mobile_init();
 //===========================================================================
 // 
 //	Loads the texture image into the hardware
@@ -197,6 +200,15 @@ void FHardwareTexture::LoadImage(unsigned char * buffer,int w, int h, unsigned i
 	bool deletebuffer=false;
 	bool use_mipmapping = TexFilter[gl_texture_filter].mipmapping;
 
+#ifdef __MOBILE__
+    static int temp = 0;
+    if (!temp)
+    {
+        mobile_init();
+        temp = 1;
+    }
+#endif
+    
 	if (alphatexture) texformat=GL_ALPHA8;
 	else if (forcenocompression) texformat = GL_RGBA8;
 	if (glTexID==0) glGenTextures(1,&glTexID);
@@ -235,6 +247,30 @@ void FHardwareTexture::LoadImage(unsigned char * buffer,int w, int h, unsigned i
 				buffer=scaledbuffer;
 			}
 		}
+#ifdef USE_GLES
+        else if ((rw > w) || ( rh > h))
+        {
+            // The image must be copied to a larger buffer
+            unsigned char * scaledbuffer=(unsigned char *)calloc(4,rw * (rh+1));
+            if (scaledbuffer)
+            {
+                for(int y=0;y<h;y++)
+                {
+                    memcpy(scaledbuffer + rw * y * 4, buffer + w * y * 4, w * 4);
+                    // duplicate the last row to eliminate texture filtering artifacts on borders!
+                    if (rw>w)
+                        memcpy(	scaledbuffer + rw * y * 4 + w * 4,
+                               scaledbuffer + rw * y * 4 + w * 4 -4, 4);
+                }
+                // also duplicate the last line for the same reason!
+                memcpy(	scaledbuffer + rw * h * 4, 	scaledbuffer + rw * (h-1) * 4, w*4 + 4);
+                
+                deletebuffer=true;
+                buffer=scaledbuffer;
+            }
+        }
+#endif
+        
 	}
 	glTexImage2D(GL_TEXTURE_2D, 0, texformat, rw, rh, 0, GL_RGBA, GL_UNSIGNED_BYTE, buffer);
 
diff --git a/src/mobile/game_interface.cpp b/src/mobile/game_interface.cpp
new file mode 100755
index 0000000..36e0cb6
--- /dev/null
+++ b/src/mobile/game_interface.cpp
@@ -0,0 +1,434 @@
+
+
+extern int main_android (int argc, char **argv);
+
+
+
+#include "game_interface.h"
+
+#include <signal.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <sys/types.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+
+#include "SDL.h"
+#include "SDL_keycode.h"
+
+#include "templates.h"
+#include "version.h"
+#include "doomdef.h"
+#include "doomstat.h"
+#include "d_protocol.h"
+#include "d_netinf.h"
+#include "intermission/intermission.h"
+#include "m_argv.h"
+#include "m_misc.h"
+#include "menu/menu.h"
+#include "m_random.h"
+#include "m_crc32.h"
+#include "i_system.h"
+#include "i_input.h"
+#include "p_saveg.h"
+#include "p_tick.h"
+#include "d_main.h"
+#include "wi_stuff.h"
+#include "hu_stuff.h"
+#include "st_stuff.h"
+#include "am_map.h"
+#include "c_console.h"
+#include "c_cvars.h"
+#include "c_bind.h"
+#include "c_dispatch.h"
+#include "v_video.h"
+#include "w_wad.h"
+#include "p_local.h"
+#include "s_sound.h"
+#include "gstrings.h"
+#include "r_sky.h"
+#include "g_game.h"
+#include "g_level.h"
+#include "b_bot.h"			//Added by MC:
+#include "sbar.h"
+#include "m_swap.h"
+#include "m_png.h"
+#include "gi.h"
+#include "a_keys.h"
+#include "a_artifacts.h"
+#include "r_data/r_translate.h"
+#include "cmdlib.h"
+#include "d_net.h"
+#include "d_event.h"
+#include "p_acs.h"
+#include "m_joy.h"
+#include "farchive.h"
+#include "r_renderer.h"
+#include "r_data/colormaps.h"
+
+
+
+extern "C"
+{
+extern int SDL_SendKeyboardKey(Uint8 state, SDL_Scancode scancode);
+}
+
+int PortableKeyEvent(int state, int code, int unicode){
+	LOGI("PortableKeyEvent %d %d %d\n",state,code,unicode);
+
+	if (state)
+		SDL_SendKeyboardKey(SDL_PRESSED, (SDL_Scancode)code);
+	else
+		SDL_SendKeyboardKey(SDL_RELEASED, (SDL_Scancode) code);
+
+	return 0;
+
+}
+
+void buttonChange(int state,FButtonStatus *button)
+{
+	if (state)
+	{
+		button->bDown = true;
+		button->bWentDown  = true;
+	}
+	else
+	{
+		button->bWentUp = true;
+		button->bDown = false;
+	}
+}
+
+void PortableAction(int state, int action)
+{
+	LOGI("PortableAction %d   %d",state,action);
+
+	if (PortableGetScreenMode() == TS_MENU)
+	{
+		if (action >= PORT_ACT_MENU_UP && action <= PORT_ACT_MENU_BACK)
+		{
+
+			int sdl_code [] = { SDL_SCANCODE_UP, SDL_SCANCODE_DOWN, SDL_SCANCODE_LEFT,
+					SDL_SCANCODE_RIGHT, SDL_SCANCODE_RETURN, SDL_SCANCODE_ESCAPE };
+			PortableKeyEvent(state, sdl_code[action-PORT_ACT_MENU_UP], 0);
+			return;
+
+		}
+	}
+	else
+	{
+
+		if ((action >= PORT_ACT_CUSTOM_0) && (action <= PORT_ACT_CUSTOM_7))
+		{
+			PortableKeyEvent(state, SDL_SCANCODE_A + action - PORT_ACT_CUSTOM_0, 0);
+		}
+		else
+		{
+			switch (action)
+			{
+			case PORT_ACT_LEFT:
+				buttonChange(state,&Button_Left);
+				break;
+			case PORT_ACT_RIGHT:
+				buttonChange(state,&Button_Right);
+				break;
+			case PORT_ACT_FWD:
+				buttonChange(state,&Button_Forward);
+				break;
+			case PORT_ACT_BACK:
+				buttonChange(state,&Button_Back);
+				break;
+			case PORT_ACT_MOVE_LEFT:
+				buttonChange(state,&Button_MoveLeft);
+				break;
+			case PORT_ACT_MOVE_RIGHT:
+				buttonChange(state,&Button_MoveRight);
+				break;
+			case PORT_ACT_USE:
+				buttonChange(state,&Button_Use);
+				break;
+			case PORT_ACT_ATTACK:
+				buttonChange(state,&Button_Attack);
+				break;
+			case PORT_ACT_ALT_ATTACK:
+				buttonChange(state,&Button_AltAttack);
+				break;
+			case PORT_ACT_JUMP:
+				buttonChange(state,&Button_Jump);
+				break;
+			case PORT_ACT_DOWN:
+				buttonChange(state,&Button_Crouch);
+				break;
+			case PORT_ACT_NEXT_WEP:
+				if (state)
+					PortableCommand("weapnext");
+				break;
+			case PORT_ACT_PREV_WEP:
+				if (state)
+					PortableCommand("weapprev");
+				break;
+			case PORT_ACT_MAP:
+				if (state)
+					PortableCommand("togglemap");
+				break;
+			case PORT_ACT_QUICKLOAD:
+				if (state)
+					PortableCommand("quickload");
+				break;
+			case PORT_ACT_QUICKSAVE:
+				if (state)
+					PortableCommand("quicksave");
+				break;
+			case PORT_ACT_WEAP0:
+				if (state)
+					PortableCommand("slot 0");
+				break;
+			case PORT_ACT_WEAP1:
+				if (state)
+					PortableCommand("slot 1");
+				break;
+			case PORT_ACT_WEAP2:
+				if (state)
+					PortableCommand("slot 2");
+				break;
+			case PORT_ACT_WEAP3:
+				if (state)
+					PortableCommand("slot 3");
+				break;
+			case PORT_ACT_WEAP4:
+				if (state)
+					PortableCommand("slot 4");
+				break;
+			case PORT_ACT_WEAP5:
+				if (state)
+					PortableCommand("slot 5");
+				break;
+			case PORT_ACT_WEAP6:
+				if (state)
+					PortableCommand("slot 6");
+				break;
+			case PORT_ACT_WEAP7:
+				if (state)
+					PortableCommand("slot 7");
+				break;
+			case PORT_ACT_WEAP8:
+				if (state)
+					PortableCommand("slot 8");
+				break;
+			case PORT_ACT_WEAP9:
+				if (state)
+					PortableCommand("slot 9");
+				break;
+			}
+		}
+	}
+}
+
+int mdx=0,mdy=0;
+void PortableMouse(float dx,float dy)
+{
+	dx *= 1500;
+	dy *= 1200;
+
+	mdx += dx;
+	mdy += dy;
+}
+
+int absx=0,absy=0;
+void PortableMouseAbs(float x,float y)
+{
+	absx = x;
+	absy = y;
+}
+
+
+// =================== FORWARD and SIDE MOVMENT ==============
+
+float forwardmove_android, sidemove_android; //Joystick mode
+
+void PortableMoveFwd(float fwd)
+{
+	if (fwd > 1)
+		fwd = 1;
+	else if (fwd < -1)
+		fwd = -1;
+
+	forwardmove_android = fwd;
+}
+
+void PortableMoveSide(float strafe)
+{
+	if (strafe > 1)
+		strafe = 1;
+	else if (strafe < -1)
+		strafe = -1;
+
+	sidemove_android = strafe;
+}
+
+void PortableMove(float fwd, float strafe)
+{
+	PortableMoveFwd(fwd);
+	PortableMoveSide(strafe);
+}
+
+//======================================================================
+
+//Look up and down
+int look_pitch_mode;
+float look_pitch_mouse,look_pitch_abs,look_pitch_joy;
+void PortableLookPitch(int mode, float pitch)
+{
+	look_pitch_mode = mode;
+	switch(mode)
+	{
+	case LOOK_MODE_MOUSE:
+		look_pitch_mouse += pitch;
+		break;
+	case LOOK_MODE_ABSOLUTE:
+		look_pitch_abs = pitch;
+		break;
+	case LOOK_MODE_JOYSTICK:
+		look_pitch_joy = pitch;
+		break;
+	}
+}
+
+//left right
+int look_yaw_mode;
+float look_yaw_mouse,look_yaw_joy;
+void PortableLookYaw(int mode, float yaw)
+{
+	look_yaw_mode = mode;
+	switch(mode)
+	{
+	case LOOK_MODE_MOUSE:
+		look_yaw_mouse += yaw;
+		break;
+	case LOOK_MODE_JOYSTICK:
+		look_yaw_joy = yaw;
+		break;
+	}
+}
+
+
+
+
+void PortableInit(int argc,const char ** argv){
+	main_android(argc,(char **)argv);
+}
+
+extern bool		automapactive;
+bool bindingbutton = false;
+
+touchscreemode_t PortableGetScreenMode()
+{
+
+	if (menuactive != MENU_Off)
+	{
+		if (bindingbutton)
+			return TS_CUSTOM;
+		else
+			return TS_MENU;
+	}
+	else if (gamestate == GS_LEVEL) // In a game
+	{
+		if (automapactive)
+			return TS_MAP;
+		else
+			return TS_GAME;
+	}
+	else
+		return TS_BLANK;
+
+}
+
+
+int PortableShowKeyboard(void){
+
+	return 0;
+}
+
+const char *cmd_to_run = NULL;
+void PortableCommand(const char * cmd)
+{
+	cmd_to_run = cmd;
+}
+
+float am_zoom = 0, am_pan_x = 0,am_pan_y = 0;
+void PortableAutomapControl(float zoom, float x, float y)
+{
+	am_zoom += zoom;
+	am_pan_x += x;
+	am_pan_y += y;
+	LOGI("am_pan_x = %f",am_pan_x);
+}
+
+
+void Android_AM_controls(float *zoom, fixed_t *pan_x,fixed_t *pan_y)
+{
+	if (am_zoom)
+	{
+		if (am_zoom > 0)
+			*zoom = 1 + am_zoom;
+		if (am_zoom < 0)
+			*zoom = -1 + am_zoom;
+
+		am_zoom = 0;
+	}
+
+	*pan_x += (fixed_t)am_pan_x;
+	*pan_y += -(fixed_t)am_pan_y;
+	am_pan_x = am_pan_y = 0;
+	//LOGI("zoom = %f",*zoom);
+}
+
+extern fixed_t			forwardmove[2], sidemove[2];
+extern void G_AddViewAngle (int yaw);
+extern void G_AddViewPitch (int look);
+//void AddCommandString (char *cmd, int keynum=0);
+
+void Mobile_IN_Move(ticcmd_t* cmd )
+{
+
+	cmd->ucmd.forwardmove  += forwardmove_android * forwardmove[1];
+	cmd->ucmd.sidemove  += sidemove_android   * sidemove[1];
+
+	//LOGI("Side: %d   %d",(int)(sidemove_android  * sidemove[1]),(int)(-look_yaw_joy * 1000));
+
+	switch(look_pitch_mode)
+	{
+	case LOOK_MODE_MOUSE:
+		G_AddViewPitch(look_pitch_mouse * 30000);
+		look_pitch_mouse = 0;
+		break;
+	case LOOK_MODE_JOYSTICK:
+		G_AddViewPitch(-look_pitch_joy * 1000);
+		break;
+	}
+
+
+	switch(look_yaw_mode)
+	{
+	case LOOK_MODE_MOUSE:
+		G_AddViewAngle(-look_yaw_mouse * 50000);
+		look_yaw_mouse = 0;
+		break;
+	case LOOK_MODE_JOYSTICK:
+		G_AddViewAngle(-look_yaw_joy * 1000);
+		break;
+	}
+
+	if (cmd_to_run)
+	{
+		AddCommandString((char*)cmd_to_run,0);
+		cmd_to_run = NULL;
+	}
+}
+
+
+
diff --git a/src/mobile/game_interface.h b/src/mobile/game_interface.h
new file mode 100755
index 0000000..0f62346
--- /dev/null
+++ b/src/mobile/game_interface.h
@@ -0,0 +1,45 @@
+#include "port_act_defs.h"
+
+#ifdef __IOS__
+#define LOGI printf
+#endif
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+typedef enum
+{
+	TS_BLANK,
+	TS_MENU,
+	TS_GAME,
+	TS_MAP,
+	TS_CONSOLE,
+	TS_CUSTOM
+} touchscreemode_t;
+
+
+int PortableKeyEvent(int state, int code ,int unitcode);
+void PortableAction(int state, int action);
+
+void PortableMove(float fwd, float strafe);
+void PortableMoveFwd(float fwd);
+void PortableMoveSide(float strafe);
+void PortableLookPitch(int mode, float pitch);
+void PortableLookYaw(int mode, float pitch);
+void PortableCommand(const char * cmd);
+
+void PortableAutomapControl(float zoom, float x, float y);
+
+void PortableInit(int argc,const char ** argv);
+void PortableFrame(void);
+
+int PortableShowKeyboard(void);
+
+touchscreemode_t PortableGetScreenMode();
+
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/src/mobile/ios_interface.h b/src/mobile/ios_interface.h
new file mode 100644
index 0000000..c31b175
--- /dev/null
+++ b/src/mobile/ios_interface.h
@@ -0,0 +1,26 @@
+//
+//  ios_interface.h
+//  D-Touch
+//
+//  Created by Emile Belanger on 17/01/2016.
+//  Copyright © 2016 Beloko Games. All rights reserved.
+//
+
+#ifndef ios_interface_h
+#define ios_interface_h
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+const char * getPngDirectory();
+const char * getWriteDirectory();
+    
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* ios_interface_h */
diff --git a/src/mobile/ios_interface.m b/src/mobile/ios_interface.m
new file mode 100644
index 0000000..db89038
--- /dev/null
+++ b/src/mobile/ios_interface.m
@@ -0,0 +1,21 @@
+//
+//  ios_interface.m
+//  D-Touch
+//
+//  Created by Emile Belanger on 17/01/2016.
+//  Copyright © 2016 Beloko Games. All rights reserved.
+//
+
+#import <Foundation/Foundation.h>
+#import "ios_interface.h"
+
+NSString * pngDir;
+
+const char * getPngDirectory()
+{
+    pngDir = [[NSBundle mainBundle] resourcePath];
+    pngDir  = [pngDir stringByAppendingString:@"/png/"];
+    
+    return [pngDir cStringUsingEncoding:[NSString defaultCStringEncoding]];
+}
+
diff --git a/src/mobile/touch_interface.cpp b/src/mobile/touch_interface.cpp
new file mode 100755
index 0000000..ecef375
--- /dev/null
+++ b/src/mobile/touch_interface.cpp
@@ -0,0 +1,714 @@
+
+#include "TouchControlsInterface.h"
+
+
+#include "TouchControlsContainer.h"
+
+
+#include "SDL_beloko_extra.h"
+
+#include "ios_interface.h"
+
+//#include "JNITouchControlsUtils.h"
+
+
+
+extern "C"
+{
+#define DEFAULT_FADE_FRAMES 10
+
+#include "game_interface.h"
+#include "SDL_keycode.h"
+
+int mobile_screen_width;
+int mobile_screen_height;
+
+
+touchscreemode_t currentScreenMode = TS_BLANK;
+
+#define KEY_SHOW_WEAPONS 0x1000
+#define KEY_SHOOT        0x1001
+
+#define KEY_SHOW_INV     0x1006
+#define KEY_QUICK_CMD    0x1007
+#define KEY_SHOW_KBRD    0x1008
+#define KEY_SHOW_CUSTOM  0x1009
+
+
+
+float gameControlsAlpha = 0.5;
+bool turnMouseMode = true;
+bool invertLook = false;
+bool precisionShoot = false;
+bool showSticks = true;
+bool hideTouchControls = true;
+bool enableWeaponWheel = true;
+
+//To be set by android
+    float strafe_sens = 1;
+    float forward_sens = 1;
+    float pitch_sens = 1;
+    float yaw_sens = 1;
+    
+bool shooting = false;
+
+static int controlsCreated = 0;
+touchcontrols::TouchControlsContainer controlsContainer;
+
+touchcontrols::TouchControls *tcMenuMain=0;
+touchcontrols::TouchControls *tcGameMain=0;
+touchcontrols::TouchControls *tcGameWeapons=0;
+touchcontrols::TouchControls *tcWeaponWheel=0;
+touchcontrols::TouchControls *tcInventory=0;
+touchcontrols::TouchControls *tcAutomap=0;
+touchcontrols::TouchControls *tcBlank=0;
+touchcontrols::TouchControls *tcCutomButtons=0;
+
+
+
+//So can hide and show these buttons
+touchcontrols::TouchJoy *touchJoyLeft;
+touchcontrols::TouchJoy *touchJoyRight;
+
+GLint     matrixMode;
+GLfloat   projection[16];
+GLfloat   model[16];
+
+void openGLStart()
+{
+    
+    glGetIntegerv(GL_MATRIX_MODE, &matrixMode);
+    glGetFloatv(GL_PROJECTION_MATRIX, projection);
+    glGetFloatv(GL_MODELVIEW_MATRIX, model);
+    
+    glMatrixMode(GL_PROJECTION);
+    glLoadIdentity();
+    //rgluOrtho2D(0.0f, winWidth, 0.0f, winHeight);
+    glViewport(0, 0, mobile_screen_width, mobile_screen_height);
+    glOrthof(0.0f, mobile_screen_width, mobile_screen_height, 0.0f, -1.0f, 1.0f);
+    glMatrixMode(GL_MODELVIEW);
+    //glPushMatrix();
+    glLoadIdentity();
+    //return;
+    //-----------------
+    glDisable(GL_ALPHA_TEST);
+    glDisable(GL_DEPTH_TEST);
+    glDisableClientState(GL_COLOR_ARRAY);
+    glEnableClientState(GL_VERTEX_ARRAY);
+    glEnableClientState(GL_TEXTURE_COORD_ARRAY );
+    
+    
+    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+    glEnable (GL_BLEND);
+  
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glEnable(GL_TEXTURE_2D);
+    glDisable(GL_CULL_FACE);
+}
+
+void openGLEnd()
+{
+    
+    glMatrixMode(GL_MODELVIEW);
+    glLoadMatrixf(model);
+    
+    glMatrixMode(GL_PROJECTION);
+    glLoadMatrixf(projection);
+    
+    
+    if (matrixMode == GL_MODELVIEW)
+    {
+        glMatrixMode(GL_MODELVIEW);
+    }
+    else if (matrixMode == GL_TEXTURE)
+    {
+        glMatrixMode(GL_TEXTURE);
+    }
+    /*
+     glDisable (GL_BLEND);
+     glColor4f(1,1,1,1);
+     glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+     //glMatrixMode(GL_PROJECTION);
+     glLoadIdentity();
+     */
+}
+
+void gameSettingsButton(int state)
+{
+    if (state == 1)
+    {
+        //showTouchSettings();
+    }
+}
+
+void customSettingsButton(int state)
+{
+    if (state == 1)
+    {
+        //showEditButtons();
+    }
+}
+
+
+extern unsigned int Sys_Milliseconds(void);
+
+static unsigned int reload_time_down;
+void gameButton(int state,int code)
+{
+    
+    if (code == KEY_SHOOT)
+    {
+        shooting = state;
+        PortableAction(state,PORT_ACT_ATTACK);
+    }
+    else if (code == KEY_SHOW_WEAPONS)
+    {
+        if (state == 1)
+            if (!tcGameWeapons->enabled)
+            {
+                
+                tcGameWeapons->animateIn(5);
+            }
+    }
+    else if (code == KEY_SHOW_INV)
+    {
+        if (state == 1)
+        {
+            if (!tcInventory->enabled)
+            {
+                tcInventory->animateIn(5);
+            }
+            else
+                tcInventory->animateOut(5);
+        }
+    }
+    else if (code == KEY_SHOW_CUSTOM)
+    {
+        if (state == 1)
+        {
+            if (!tcCutomButtons->enabled)
+            {
+                tcCutomButtons->setEnabled(true);
+                tcCutomButtons->setAlpha(gameControlsAlpha);
+                tcCutomButtons->fade(touchcontrols::FADE_IN,5);
+            }
+            else
+                tcCutomButtons->fade(touchcontrols::FADE_OUT,5);
+        }
+    }
+    else if  (code == KEY_SHOW_KBRD)
+    {
+        //if (state)
+        //    showKeyboard(true);
+    }
+    else
+    {
+        PortableAction(state, code);
+    }
+}
+
+void blankButton(int state,int code)
+{
+    PortableAction(state, PORT_ACT_USE);
+    PortableKeyEvent(state, SDL_SCANCODE_RETURN, 0);
+}
+
+void customButton(int state,int code)
+{
+    PortableKeyEvent(state, code, 0);
+    //if (state == 0)
+    //	tcCutomButtons->setEnabled(false);
+}
+
+//Weapon wheel callbacks
+void weaponWheelSelected(int enabled)
+{
+    if (enabled)
+        tcWeaponWheel->fade(touchcontrols::FADE_IN,5); //fade in
+}
+
+void weaponWheel(int segment)
+{
+    LOGI("weaponWheel %d",segment);
+    PortableAction(1,PORT_ACT_WEAP1 + segment);
+}
+
+void menuButton(int state,int code)
+{
+    if (code == KEY_SHOW_KBRD)
+    {
+       // if (state)
+       //     showKeyboard(true);
+    }
+    else
+        PortableAction(state, code);
+}
+
+
+
+int left_double_action;
+int right_double_action;
+
+void left_double_tap(int state)
+{
+    //LOGTOUCH("L double %d",state);
+    if (left_double_action)
+        PortableAction(state,left_double_action);
+}
+
+void right_double_tap(int state)
+{
+    //LOGTOUCH("R double %d",state);
+    if (right_double_action)
+        PortableAction(state,right_double_action);
+}
+
+
+
+
+
+void left_stick(float joy_x, float joy_y,float mouse_x, float mouse_y)
+{
+    joy_x *=10;
+    //float strafe = joy_x*joy_x;
+    float strafe = joy_x;
+    //if (joy_x < 0)
+    //	strafe *= -1;
+    
+    PortableMove(joy_y * 15 * forward_sens,-strafe * strafe_sens);
+}
+void right_stick(float joy_x, float joy_y,float mouse_x, float mouse_y)
+{
+    //LOGI(" mouse x = %f",mouse_x);
+    int invert = invertLook?-1:1;
+    
+    float scale;
+    
+    scale = (shooting && precisionShoot)?0.3:1;
+    
+    PortableLookPitch(LOOK_MODE_MOUSE,mouse_y  * pitch_sens * invert * scale);
+    
+    if (turnMouseMode)
+        PortableLookYaw(LOOK_MODE_MOUSE,mouse_x*2*yaw_sens * scale);
+    else
+        PortableLookYaw(LOOK_MODE_JOYSTICK,joy_x*6*yaw_sens * scale);
+    
+}
+
+void inventoryButton(int state,int code)
+{
+    PortableAction(state,code);
+}
+
+//Weapon select callbacks
+void selectWeaponButton(int state, int code)
+{
+    PortableKeyEvent(state, code, 0);
+    if (state == 0)
+        tcGameWeapons->animateOut(5);
+}
+
+void automap_multitouch_mouse_move(int action,float x, float y,float dx, float dy)
+{
+    
+    if (action == MULTITOUCHMOUSE_MOVE)
+    {
+        PortableAutomapControl(0,dx*4000000,dy*4000000);
+    }
+    else if (action == MULTITOUCHMOUSE_ZOOM)
+    {
+        PortableAutomapControl(x*5,0,0);
+    }
+}
+
+
+void setHideSticks(bool v)
+{
+    if (touchJoyLeft) touchJoyLeft->setHideGraphics(v);
+    if (touchJoyRight) touchJoyRight->setHideGraphics(v);
+}
+void updateTouchScreenMode(touchscreemode_t mode)
+{
+    // LOGI("updateTouchScreenModeA %d",mode);
+    
+    if (mode != currentScreenMode){
+        
+        //first disable the last screen and fade out is necessary
+        switch(currentScreenMode){
+            case TS_BLANK:
+                tcBlank->resetOutput();
+                tcBlank->setEnabled(false);
+                break;
+            case TS_MENU:
+                tcMenuMain->resetOutput();
+                tcMenuMain->fade(touchcontrols::FADE_OUT,DEFAULT_FADE_FRAMES);
+                break;
+            case TS_GAME:
+                tcGameMain->resetOutput();
+                tcGameMain->fade(touchcontrols::FADE_OUT,DEFAULT_FADE_FRAMES);
+                tcGameWeapons->setEnabled(false);
+                tcWeaponWheel->setEnabled(false);
+                tcCutomButtons->resetOutput();
+                tcCutomButtons->setEnabled(false);
+                break;
+            case TS_MAP:
+                tcAutomap->resetOutput();
+                tcAutomap->fade(touchcontrols::FADE_OUT,DEFAULT_FADE_FRAMES);
+                break;
+            case TS_CUSTOM:
+                tcCutomButtons->resetOutput();
+                tcCutomButtons->fade(touchcontrols::FADE_OUT,DEFAULT_FADE_FRAMES);
+                break;
+        }
+        
+        //Enable the current new screen
+        switch(mode){
+            case TS_BLANK:
+                tcBlank->setEnabled(true);
+                break;
+            case TS_MENU:
+                tcMenuMain->setEnabled(true);
+                tcMenuMain->fade(touchcontrols::FADE_IN,DEFAULT_FADE_FRAMES);
+                break;
+            case TS_GAME:
+                tcGameMain->setEnabled(true);
+                tcGameMain->fade(touchcontrols::FADE_IN,DEFAULT_FADE_FRAMES);
+                tcWeaponWheel->setEnabled(true);
+                break;
+            case TS_MAP:
+                tcAutomap->setEnabled(true);
+                tcAutomap->fade(touchcontrols::FADE_IN,DEFAULT_FADE_FRAMES);
+                break;
+            case TS_CUSTOM:
+                tcCutomButtons->setEnabled(true);
+                tcCutomButtons->setAlpha(1.0);
+                tcCutomButtons->fade(touchcontrols::FADE_IN,DEFAULT_FADE_FRAMES);
+                break;
+        }
+        
+        currentScreenMode = mode;
+    }
+    
+}
+
+void frameControls()
+{
+    
+    updateTouchScreenMode(PortableGetScreenMode());
+    
+    setHideSticks(!showSticks);
+    
+    controlsContainer.draw();
+}
+
+void initControls(int width, int height,const char * graphics_path)
+{
+    touchcontrols::GLScaleWidth = (float)width;
+    touchcontrols::GLScaleHeight = (float)height;
+    
+    LOGI("initControls %d x %d,x path = %s",width,height,graphics_path);
+    
+    if (!controlsCreated)
+    {
+        LOGI("creating controls");
+        
+        touchcontrols::setGraphicsBasePath(graphics_path);
+        //setControlsContainer(&controlsContainer);
+        
+        controlsContainer.openGL_start.connect( sigc::ptr_fun(&openGLStart));
+        controlsContainer.openGL_end.connect( sigc::ptr_fun(&openGLEnd));
+        
+        
+        tcMenuMain = new touchcontrols::TouchControls("menu",false,false);
+        tcGameMain = new touchcontrols::TouchControls("game",false,true,1,true);
+        tcGameWeapons = new touchcontrols::TouchControls("weapons",false,true,1,false);
+        tcInventory  = new touchcontrols::TouchControls("inventory",false,true,1,false);
+        tcWeaponWheel = new touchcontrols::TouchControls("weapon_wheel",false,true,1,false);
+        tcAutomap = new touchcontrols::TouchControls("automap",false,false);
+        tcBlank = new touchcontrols::TouchControls("blank",true,false);
+        tcCutomButtons = new touchcontrols::TouchControls("custom_buttons",false,true,1,true);
+        
+        //Menu
+        tcMenuMain->addControl(new touchcontrols::Button("down_arrow",touchcontrols::RectF(20,13,23,16),"arrow_down",PORT_ACT_MENU_DOWN));
+        tcMenuMain->addControl(new touchcontrols::Button("up_arrow",touchcontrols::RectF(20,10,23,13),"arrow_up",PORT_ACT_MENU_UP));
+        tcMenuMain->addControl(new touchcontrols::Button("left_arrow",touchcontrols::RectF(17,13,20,16),"arrow_left",PORT_ACT_MENU_LEFT));
+        tcMenuMain->addControl(new touchcontrols::Button("right_arrow",touchcontrols::RectF(23,13,26,16),"arrow_right",PORT_ACT_MENU_RIGHT));
+        tcMenuMain->addControl(new touchcontrols::Button("enter",touchcontrols::RectF(0,10,6,16),"enter",PORT_ACT_MENU_SELECT));
+        tcMenuMain->addControl(new touchcontrols::Button("keyboard",touchcontrols::RectF(0,0,3,3),"keyboard",KEY_SHOW_KBRD));
+        tcMenuMain->signal_button.connect(  sigc::ptr_fun(&menuButton) );
+        tcMenuMain->setAlpha(0.8);
+        
+        
+        //Game
+        tcGameMain->setAlpha(gameControlsAlpha);
+        tcGameMain->addControl(new touchcontrols::Button("attack",touchcontrols::RectF(20,7,23,10),"shoot",KEY_SHOOT));
+        
+        tcGameMain->addControl(new touchcontrols::Button("use",touchcontrols::RectF(23,6,26,9),"use",PORT_ACT_USE));
+        tcGameMain->addControl(new touchcontrols::Button("quick_save",touchcontrols::RectF(24,0,26,2),"save",PORT_ACT_QUICKSAVE));
+        tcGameMain->addControl(new touchcontrols::Button("quick_load",touchcontrols::RectF(20,0,22,2),"load",PORT_ACT_QUICKLOAD));
+        tcGameMain->addControl(new touchcontrols::Button("map",touchcontrols::RectF(2,0,4,2),"map",PORT_ACT_MAP));
+        tcGameMain->addControl(new touchcontrols::Button("keyboard",touchcontrols::RectF(8,0,10,2),"keyboard",KEY_SHOW_KBRD));
+        
+        
+        tcGameMain->addControl(new touchcontrols::Button("jump",touchcontrols::RectF(24,3,26,5),"jump",PORT_ACT_JUMP,false,true));
+        tcGameMain->addControl(new touchcontrols::Button("crouch",touchcontrols::RectF(24,14,26,16),"crouch",PORT_ACT_DOWN,false,true));
+        tcGameMain->addControl(new touchcontrols::Button("attack_alt",touchcontrols::RectF(21,5,23,7),"shoot_alt",PORT_ACT_ALT_ATTACK,false,true));
+        tcGameMain->addControl(new touchcontrols::Button("show_custom",touchcontrols::RectF(0,7,2,9),"Custom_Show",KEY_SHOW_CUSTOM,false,true));
+        
+        
+        tcGameMain->addControl(new touchcontrols::Button("show_weapons",touchcontrols::RectF(12,14,14,16),"show_weapons",KEY_SHOW_WEAPONS));
+        tcGameMain->addControl(new touchcontrols::Button("next_weapon",touchcontrols::RectF(0,3,3,5),"next_weap",PORT_ACT_NEXT_WEP));
+        tcGameMain->addControl(new touchcontrols::Button("prev_weapon",touchcontrols::RectF(0,5,3,7),"prev_weap",PORT_ACT_PREV_WEP));
+        
+        
+        touchJoyRight = new touchcontrols::TouchJoy("touch",touchcontrols::RectF(17,4,26,16),"look_arrow");
+        tcGameMain->addControl(touchJoyRight);
+        touchJoyRight->signal_move.connect(sigc::ptr_fun(&right_stick) );
+        touchJoyRight->signal_double_tap.connect(sigc::ptr_fun(&right_double_tap) );
+        
+        touchJoyLeft = new touchcontrols::TouchJoy("stick",touchcontrols::RectF(0,7,8,16),"strafe_arrow");
+        tcGameMain->addControl(touchJoyLeft);
+        touchJoyLeft->signal_move.connect(sigc::ptr_fun(&left_stick) );
+        touchJoyLeft->signal_double_tap.connect(sigc::ptr_fun(&left_double_tap) );
+        
+        tcGameMain->signal_button.connect(  sigc::ptr_fun(&gameButton) );
+        tcGameMain->signal_settingsButton.connect(  sigc::ptr_fun(&gameSettingsButton) );
+        
+        
+        //Weapons
+        tcGameWeapons->addControl(new touchcontrols::Button("weapon1",touchcontrols::RectF(1,14,3,16),"key_1",SDL_SCANCODE_1));
+        tcGameWeapons->addControl(new touchcontrols::Button("weapon2",touchcontrols::RectF(4,14,6,16),"key_2",SDL_SCANCODE_2));
+        tcGameWeapons->addControl(new touchcontrols::Button("weapon3",touchcontrols::RectF(7,14,9,16),"key_3",SDL_SCANCODE_3));
+        tcGameWeapons->addControl(new touchcontrols::Button("weapon4",touchcontrols::RectF(10,14,12,16),"key_4",SDL_SCANCODE_4));
+        
+        tcGameWeapons->addControl(new touchcontrols::Button("weapon5",touchcontrols::RectF(14,14,16,16),"key_5",SDL_SCANCODE_5));
+        tcGameWeapons->addControl(new touchcontrols::Button("weapon6",touchcontrols::RectF(17,14,19,16),"key_6",SDL_SCANCODE_6));
+        tcGameWeapons->addControl(new touchcontrols::Button("weapon7",touchcontrols::RectF(20,14,22,16),"key_7",SDL_SCANCODE_7));
+        tcGameWeapons->addControl(new touchcontrols::Button("weapon8",touchcontrols::RectF(23,14,25,16),"key_8",SDL_SCANCODE_8));
+        tcGameWeapons->signal_button.connect(  sigc::ptr_fun(&selectWeaponButton) );
+        tcGameWeapons->setAlpha(0.8);
+        
+        //Weapon wheel
+        touchcontrols::WheelSelect *wheel = new touchcontrols::WheelSelect("weapon_wheel",touchcontrols::RectF(7,2,19,14),"weapon_wheel",8);
+        wheel->signal_selected.connect(sigc::ptr_fun(&weaponWheel) );
+        wheel->signal_enabled.connect(sigc::ptr_fun(&weaponWheelSelected));
+        tcWeaponWheel->addControl(wheel);
+        tcWeaponWheel->setAlpha(0.8);
+#if defined(CHOC_HEXEN)
+        //Inventory
+        tcInventory->addControl(new touchcontrols::Button("invuse",touchcontrols::RectF(3,14,5,16),"enter",PORT_ACT_INVUSE));
+        tcInventory->addControl(new touchcontrols::Button("invprev",touchcontrols::RectF(6,14,8,16),"arrow_left",PORT_ACT_INVPREV));
+        tcInventory->addControl(new touchcontrols::Button("invnext",touchcontrols::RectF(8,14,10,16),"arrow_right",PORT_ACT_INVNEXT));
+#endif
+#if defined(CHOC_STRIFE)
+        //Inventory
+        tcInventory->addControl(new touchcontrols::Button("invuse",touchcontrols::RectF(0,14,2,16),"enter",PORT_ACT_INVUSE));
+        tcInventory->addControl(new touchcontrols::Button("invprev",touchcontrols::RectF(0,12,2,14),"arrow_left",PORT_ACT_INVPREV));
+        tcInventory->addControl(new touchcontrols::Button("invnext",touchcontrols::RectF(2,12,4,14),"arrow_right",PORT_ACT_INVNEXT));
+#endif
+        
+        tcInventory->signal_button.connect(  sigc::ptr_fun(&inventoryButton) );
+        tcInventory->setAlpha(0.5);
+        
+        
+        //Auto Map
+        touchcontrols::MultitouchMouse *multimouse = new touchcontrols::MultitouchMouse("gamemouse",touchcontrols::RectF(0,0,26,16),"");
+        multimouse->setHideGraphics(true);
+        tcAutomap->addControl(multimouse);
+        multimouse->signal_action.connect(sigc::ptr_fun(&automap_multitouch_mouse_move) );
+        tcAutomap->addControl(new touchcontrols::Button("map",touchcontrols::RectF(2,0,4,2),"map",PORT_ACT_MAP));
+        tcAutomap->signal_button.connect(  sigc::ptr_fun(&gameButton) );
+        
+        
+        //Blank
+        tcBlank->addControl(new touchcontrols::Button("enter",touchcontrols::RectF(0,0,26,16),"",0x123));
+        tcBlank->signal_button.connect(  sigc::ptr_fun(&blankButton) );
+        
+        //Custom Controls
+        tcCutomButtons->addControl(new touchcontrols::Button("A",touchcontrols::RectF(5,5,7,7),"Custom_1",SDL_SCANCODE_A,false,false));
+        tcCutomButtons->addControl(new touchcontrols::Button("B",touchcontrols::RectF(7,5,9,7),"Custom_2",SDL_SCANCODE_B,false,false));
+        tcCutomButtons->addControl(new touchcontrols::Button("C",touchcontrols::RectF(5,7,7,9),"Custom_3",SDL_SCANCODE_C,false,false));
+        
+        tcCutomButtons->addControl(new touchcontrols::Button("D",touchcontrols::RectF(7,7,9,9),"Custom_4",SDL_SCANCODE_D,false,false));
+        tcCutomButtons->addControl(new touchcontrols::Button("E",touchcontrols::RectF(5,9,7,11),"Custom_5",SDL_SCANCODE_E,false,false));
+        tcCutomButtons->addControl(new touchcontrols::Button("F",touchcontrols::RectF(7,9,9,11),"Custom_6",SDL_SCANCODE_F,false,false));
+        tcCutomButtons->setColor(0.7,0.7,1.f);
+        
+        tcCutomButtons->signal_button.connect(sigc::ptr_fun(&customButton));
+        tcCutomButtons->signal_settingsButton.connect(  sigc::ptr_fun(&customSettingsButton) );
+        tcCutomButtons->setAlpha(0.8);
+        
+        
+        controlsContainer.addControlGroup(tcGameMain);
+        controlsContainer.addControlGroup(tcGameWeapons);
+        controlsContainer.addControlGroup(tcCutomButtons);
+        controlsContainer.addControlGroup(tcMenuMain);
+        controlsContainer.addControlGroup(tcWeaponWheel);
+        //controlsContainer.addControlGroup(tcInventory);
+        controlsContainer.addControlGroup(tcAutomap);
+        controlsContainer.addControlGroup(tcBlank);
+        controlsCreated = 1;
+        
+        tcGameMain->setXMLFile((std::string)graphics_path +  "/game_gz.xml");
+        tcInventory->setXMLFile((std::string)graphics_path +  "/inventory_gz.xml");
+        tcWeaponWheel->setXMLFile((std::string)graphics_path +  "/weaponwheel_gz.xml");
+        tcGameWeapons->setXMLFile((std::string)graphics_path +  "/weapons_gz.xml");
+        tcCutomButtons->setXMLFile((std::string)graphics_path +  "/custom_buttons_0_gz.xml");
+    }
+    else
+        LOGI("NOT creating controls");
+    
+    SDL_SetSwapBufferCallBack(frameControls);
+    
+    controlsContainer.initGL();
+}
+
+
+
+
+
+void setTouchSettings(float alpha,float strafe,float fwd,float pitch,float yaw,int other)
+{
+    
+    gameControlsAlpha = alpha;
+    if (tcGameMain)
+        tcGameMain->setAlpha(gameControlsAlpha);
+    
+    turnMouseMode   = other & 0x2?true:false;
+    invertLook      = other & 0x4?true:false;
+    precisionShoot  = other & 0x8?true:false;
+    showSticks      = other & 0x1000?true:false;
+    enableWeaponWheel  = other & 0x2000?true:false;
+    
+    if (tcWeaponWheel)
+        tcWeaponWheel->setEnabled(enableWeaponWheel);
+    
+    
+    hideTouchControls = other & 0x80000000?true:false;
+    
+    
+    switch ((other>>4) & 0xF)
+    {
+        case 1:
+            left_double_action = PORT_ACT_ATTACK;
+            break;
+        case 2:
+            left_double_action = PORT_ACT_JUMP;
+            break;
+        default:
+            left_double_action = 0;
+    }
+    
+    switch ((other>>8) & 0xF)
+    {
+        case 1:
+            right_double_action = PORT_ACT_ATTACK;
+            break;
+        case 2:
+            right_double_action = PORT_ACT_JUMP;
+            break;
+        default:
+            right_double_action = 0;
+    }
+    
+    strafe_sens = strafe;
+    forward_sens = fwd;
+    pitch_sens = pitch;
+    yaw_sens = yaw;
+    
+}
+
+int quit_now = 0;
+
+#define EXPORT_ME __attribute__ ((visibility("default")))
+
+
+int argc=1;
+const char * argv[32];
+std::string graphicpath;
+
+const char * getFilesPath()
+{
+    return graphicpath.c_str(); //graphics path is the same as files path
+}
+
+std::string game_path;
+
+const char * getGamePath()
+{
+    return game_path.c_str();
+}
+
+std::string home_env;
+
+int android_audio_rate;
+
+void mobile_init()
+{
+    mobile_screen_width = 1152;
+    mobile_screen_height = 640;
+    
+    std::string pngPath = getPngDirectory();
+   //pngPath += "/../png/";
+    LOGI("PNG Path = %s\n",pngPath.c_str());
+    
+    initControls(mobile_screen_width,-mobile_screen_height,pngPath.c_str());
+    
+    
+    SDL_SetTouchControlsInterface(&controlsContainer);
+    
+}
+    
+   /*
+jint EXPORT_ME
+JAVA_FUNC(init) ( JNIEnv* env,	jobject thiz,jstring graphics_dir,jint audio_rate,jobjectArray argsArray,jint lowRes,jstring game_path_ )
+{
+    
+    env_ = env;
+    android_audio_rate = audio_rate;
+    
+    argv[0] = "quake";
+    int argCount = (env)->GetArrayLength( argsArray);
+    LOGI("argCount = %d",argCount);
+    for (int i=0; i<argCount; i++) {
+        jstring string = (jstring) (env)->GetObjectArrayElement( argsArray, i);
+        argv[argc] = (char *)(env)->GetStringUTFChars( string, 0);
+        LOGI("arg = %s",argv[argc]);
+        argc++;
+    }
+    
+    
+    game_path = (char *)(env)->GetStringUTFChars( game_path_, 0);
+    
+    LOGI("game_path = %s",getGamePath());
+    
+    //Needed for ecwolf to run
+    //home_env = "HOME=/" + game_path;
+    //putenv(home_env.c_str());
+    setenv("HOME", getGamePath(),1);
+    
+    putenv("TIMIDITY_CFG=../timidity.cfg");
+    
+    chdir(getGamePath());
+    
+    
+    const char * p = env->GetStringUTFChars(graphics_dir,NULL);
+    graphicpath =  std::string(p);
+    
+    
+    
+    initControls(mobile_screen_width,-mobile_screen_height,graphicpath.c_str());
+    
+    SDL_SetSwapBufferCallBack(frameControls);
+    
+    //Now done in java to keep context etc
+    SDL_SwapBufferPerformsSwap(false);
+    
+    PortableInit(argc,argv); //Never returns!!
+    
+    return 0;
+}
+    */
+    
+}
+
diff --git a/src/mobile/touch_interface.h b/src/mobile/touch_interface.h
new file mode 100644
index 0000000..f58003c
--- /dev/null
+++ b/src/mobile/touch_interface.h
@@ -0,0 +1,17 @@
+//
+//  touch_interface.h
+//  D-Touch
+//
+//  Created by Emile Belanger on 17/01/2016.
+//  Copyright © 2016 Beloko Games. All rights reserved.
+//
+
+#ifndef touch_interface_h
+#define touch_interface_h
+
+extern "C"
+{
+void mobile_init();
+}
+
+#endif /* touch_interface_h */
diff --git a/src/posix/sdl/i_main.cpp b/src/posix/sdl/i_main.cpp
index eadbb44..2bee845 100644
--- a/src/posix/sdl/i_main.cpp
+++ b/src/posix/sdl/i_main.cpp
@@ -237,6 +237,21 @@ void I_ShutdownJoysticks();
 
 int main (int argc, char **argv)
 {
+    
+    argc = 7;
+    argv = (char **)malloc((argc+1) * sizeof(char *));
+    argv[0] = "Doom";
+   argv[1] = "-width";
+      argv[2] = "1136";
+      argv[3] = "-height";
+      argv[4] = "640";
+    argv[5] = "-file";
+    argv[6] = "brutalv20b.pk3";
+    
+    
+  
+    
+    
 #if !defined (__APPLE__)
 	{
 		int s[4] = { SIGSEGV, SIGILL, SIGFPE, SIGBUS };
diff --git a/src/sound/fmodsound_studio.cpp b/src/sound/fmodsound_studio.cpp
new file mode 100755
index 0000000..22ec1b3
--- /dev/null
+++ b/src/sound/fmodsound_studio.cpp
@@ -0,0 +1,3050 @@
+/*
+ ** fmodsound.cpp
+ ** System interface for sound; uses FMOD Ex.
+ **
+ **---------------------------------------------------------------------------
+ ** Copyright 1998-2009 Randy Heit
+ ** All rights reserved.
+ **
+ ** Redistribution and use in source and binary forms, with or without
+ ** modification, are permitted provided that the following conditions
+ ** are met:
+ **
+ ** 1. Redistributions of source code must retain the above copyright
+ **    notice, this list of conditions and the following disclaimer.
+ ** 2. Redistributions in binary form must reproduce the above copyright
+ **    notice, this list of conditions and the following disclaimer in the
+ **    documentation and/or other materials provided with the distribution.
+ ** 3. The name of the author may not be used to endorse or promote products
+ **    derived from this software without specific prior written permission.
+ **
+ ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ ** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ ** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ ** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ ** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ ** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ ** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ **---------------------------------------------------------------------------
+ **
+ */
+
+// HEADER FILES ------------------------------------------------------------
+
+#ifdef _WIN32
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <mmsystem.h>
+extern HWND Window;
+#define USE_WINDOWS_DWORD
+#else
+#define FALSE 0
+#define TRUE 1
+#endif
+#ifdef __APPLE__
+#include <stdlib.h>
+#elif __sun
+#include <alloca.h>
+#else
+#include <malloc.h>
+#endif
+
+#include "templates.h"
+#include "fmodsound_studio.h"
+#include "c_cvars.h"
+#include "i_system.h"
+#include "i_music.h"
+#include "v_text.h"
+#include "v_video.h"
+#include "v_palette.h"
+#include "cmdlib.h"
+#include "s_sound.h"
+
+#if FMOD_VERSION > 0x42899 && FMOD_VERSION < 0x43800
+#error You are trying to compile with an unsupported version of FMOD.
+#endif
+
+// MACROS ------------------------------------------------------------------
+
+// killough 2/21/98: optionally use varying pitched sounds
+#define PITCH(freq,pitch) (snd_pitched ? ((freq)*(pitch))/128.f : float(freq))
+
+// Just some extra for music and whatever
+#define NUM_EXTRA_SOFTWARE_CHANNELS		1
+
+#define MAX_CHANNELS				256
+
+#define SPECTRUM_SIZE				256
+
+
+
+// TYPES -------------------------------------------------------------------
+
+struct FEnumList
+{
+	const char *Name;
+	int Value;
+};
+
+// EXTERNAL FUNCTION PROTOTYPES --------------------------------------------
+
+// PUBLIC FUNCTION PROTOTYPES ----------------------------------------------
+
+// PRIVATE FUNCTION PROTOTYPES ---------------------------------------------
+
+static int Enum_NumForName(const FEnumList *list, const char *name);
+static const char *Enum_NameForNum(const FEnumList *list, int num);
+
+// EXTERNAL DATA DECLARATIONS ----------------------------------------------
+
+EXTERN_CVAR (String, snd_output)
+EXTERN_CVAR (Float, snd_sfxvolume)
+EXTERN_CVAR (Float, snd_musicvolume)
+EXTERN_CVAR (Int, snd_buffersize)
+EXTERN_CVAR (Int, snd_samplerate)
+EXTERN_CVAR (Int, snd_buffercount)
+
+EXTERN_CVAR (Bool, snd_pitched)
+EXTERN_CVAR (Int, snd_channels)
+
+extern int sfx_empty;
+
+// PUBLIC DATA DEFINITIONS -------------------------------------------------
+
+ReverbContainer *ForcedEnvironment;
+
+CVAR (Int, snd_driver, 0, CVAR_ARCHIVE|CVAR_GLOBALCONFIG)
+//CVAR (Int, snd_buffercount, 0, CVAR_ARCHIVE|CVAR_GLOBALCONFIG)
+CVAR (Bool, snd_hrtf, false, CVAR_ARCHIVE|CVAR_GLOBALCONFIG)
+CVAR (Bool, snd_waterreverb, true, CVAR_ARCHIVE|CVAR_GLOBALCONFIG)
+CVAR (String, snd_resampler, "Linear", CVAR_ARCHIVE|CVAR_GLOBALCONFIG)
+CVAR (String, snd_speakermode, "Auto", CVAR_ARCHIVE|CVAR_GLOBALCONFIG)
+CVAR (String, snd_output_format, "PCM-16", CVAR_ARCHIVE|CVAR_GLOBALCONFIG)
+CVAR (Bool, snd_profile, false, 0)
+CVAR (String, snd_midipatchset, "", CVAR_ARCHIVE|CVAR_GLOBALCONFIG);
+
+// Underwater low-pass filter cutoff frequency. Set to 0 to disable the filter.
+CUSTOM_CVAR (Float, snd_waterlp, 250, CVAR_ARCHIVE|CVAR_GLOBALCONFIG)
+{
+	// Clamp to the DSP unit's limits.
+	if (*self < 10 && *self != 0)
+	{
+		self = 10;
+	}
+	else if (*self > 22000)
+	{
+		self = 22000;
+	}
+}
+#ifndef NO_FMOD
+// PRIVATE DATA DEFINITIONS ------------------------------------------------
+
+static const ReverbContainer *PrevEnvironment;
+static bool ShowedBanner;
+
+// The rolloff callback is called during FMOD::Sound::play, so we need this
+// global variable to contain the sound info during that time for the
+// callback.
+static FRolloffInfo *GRolloff;
+static float GDistScale;
+
+// In the below lists, duplicate entries are for user selection. When
+// queried, only the first one for the particular value is shown.
+static const FEnumList OutputNames[] =
+{
+		{ "Auto",					FMOD_OUTPUTTYPE_AUTODETECT },
+		{ "Default",				FMOD_OUTPUTTYPE_AUTODETECT },
+		{ "No sound",				FMOD_OUTPUTTYPE_NOSOUND },
+
+		// Windows
+		{ "DirectSound",			FMOD_OUTPUTTYPE_DSOUND },
+		{ "DSound",					FMOD_OUTPUTTYPE_DSOUND },
+		{ "Windows Multimedia",		FMOD_OUTPUTTYPE_WINMM },
+		{ "WinMM",					FMOD_OUTPUTTYPE_WINMM },
+		{ "WaveOut",				FMOD_OUTPUTTYPE_WINMM },
+
+		{ "WASAPI",					FMOD_OUTPUTTYPE_WASAPI },
+		{ "ASIO",					FMOD_OUTPUTTYPE_ASIO },
+
+		//Android
+
+		{ "OPENSL",					FMOD_OUTPUTTYPE_OPENSL },
+		{ "Android Audio Track",	FMOD_OUTPUTTYPE_AUDIOTRACK },
+
+		// Linux
+		{ "ALSA",					FMOD_OUTPUTTYPE_ALSA },
+		{ "PulseAudio",				FMOD_OUTPUTTYPE_PULSEAUDIO },
+		{ "Pulse",					FMOD_OUTPUTTYPE_PULSEAUDIO },
+		{ "SDL",					666 },
+
+		// Mac
+		{ "Core Audio",				FMOD_OUTPUTTYPE_COREAUDIO },
+
+		{ NULL, 0 }
+};
+
+static const FEnumList SpeakerModeNames[] =
+{
+		{ "Mono",					FMOD_SPEAKERMODE_MONO },
+		{ "Stereo",					FMOD_SPEAKERMODE_STEREO },
+		{ "Quad",					FMOD_SPEAKERMODE_QUAD },
+		{ "Surround",				FMOD_SPEAKERMODE_SURROUND },
+		{ "5.1",					FMOD_SPEAKERMODE_5POINT1 },
+		{ "7.1",					FMOD_SPEAKERMODE_7POINT1 },
+		{ "1",						FMOD_SPEAKERMODE_MONO },
+		{ "2",						FMOD_SPEAKERMODE_STEREO },
+		{ "4",						FMOD_SPEAKERMODE_QUAD },
+		{ NULL, 0 }
+};
+
+static const FEnumList ResamplerNames[] =
+{
+		{ "No Interpolation",		FMOD_DSP_RESAMPLER_NOINTERP },
+		{ "NoInterp",				FMOD_DSP_RESAMPLER_NOINTERP },
+		{ "Linear",					FMOD_DSP_RESAMPLER_LINEAR },
+		{ "Cubic",					FMOD_DSP_RESAMPLER_CUBIC },
+		{ "Spline",					FMOD_DSP_RESAMPLER_SPLINE },
+		{ NULL, 0 }
+};
+
+static const FEnumList SoundFormatNames[] =
+{
+		{ "None",					FMOD_SOUND_FORMAT_NONE },
+		{ "PCM-8",					FMOD_SOUND_FORMAT_PCM8 },
+		{ "PCM-16",					FMOD_SOUND_FORMAT_PCM16 },
+		{ "PCM-24",					FMOD_SOUND_FORMAT_PCM24 },
+		{ "PCM-32",					FMOD_SOUND_FORMAT_PCM32 },
+		{ "PCM-Float",				FMOD_SOUND_FORMAT_PCMFLOAT },
+		{ NULL, 0 }
+};
+
+static const char *OpenStateNames[] =
+{
+		"Ready",
+		"Loading",
+		"Error",
+		"Connecting",
+		"Buffering",
+		"Seeking",
+		"Streaming"
+};
+
+const FMODSoundRenderer::spk FMODSoundRenderer::SpeakerNames4[4] = { "L", "R", "BL", "BR" };
+const FMODSoundRenderer::spk FMODSoundRenderer::SpeakerNamesMore[8] = { "L", "R", "C", "LFE", "BL", "BR", "SL", "SR" };
+
+// CODE --------------------------------------------------------------------
+
+//==========================================================================
+//
+// Enum_NumForName
+//
+// Returns the value of an enum name, or -1 if not found.
+//
+//==========================================================================
+
+static int Enum_NumForName(const FEnumList *list, const char *name)
+{
+	while (list->Name != NULL)
+	{
+		if (stricmp(list->Name, name) == 0)
+		{
+			return list->Value;
+		}
+		list++;
+	}
+	return -1;
+}
+
+//==========================================================================
+//
+// Enum_NameForNum
+//
+// Returns the name of an enum value. If there is more than one name for a
+// value, on the first one in the list is returned. Returns NULL if there
+// was no match.
+//
+//==========================================================================
+
+static const char *Enum_NameForNum(const FEnumList *list, int num)
+{
+	while (list->Name != NULL)
+	{
+		if (list->Value == num)
+		{
+			return list->Name;
+		}
+		list++;
+	}
+	return NULL;
+}
+
+//==========================================================================
+//
+// The container for a streaming FMOD::Sound, for playing music.
+//
+//==========================================================================
+
+class FMODStreamCapsule : public SoundStream
+{
+public:
+	FMODStreamCapsule(FMOD::Sound *stream, FMODSoundRenderer *owner, const char *url)
+: Owner(owner), Stream(NULL), Channel(NULL),
+  UserData(NULL), Callback(NULL), URL(url), Ended(false)
+{
+		SetStream(stream);
+}
+
+	FMODStreamCapsule(void *udata, SoundStreamCallback callback, FMODSoundRenderer *owner)
+	: Owner(owner), Stream(NULL), Channel(NULL),
+	  UserData(udata), Callback(callback), Ended(false)
+	{}
+
+	~FMODStreamCapsule()
+	{
+		if (Channel != NULL)
+		{
+			Channel->stop();
+		}
+		if (Stream != NULL)
+		{
+			Stream->release();
+		}
+	}
+
+	void SetStream(FMOD::Sound *stream)
+	{
+		float frequency;
+
+		Stream = stream;
+
+		// As this interface is for music, make it super-high priority.
+		if (FMOD_OK == stream->getDefaults(&frequency, NULL))
+		{
+			stream->setDefaults(frequency, 1);
+		}
+	}
+
+	bool Play(bool looping, float volume)
+	{
+		FMOD_RESULT result;
+
+		if (URL.IsNotEmpty())
+		{ // Net streams cannot be looped, because they cannot be seeked.
+			looping = false;
+		}
+		Stream->setMode((looping ? FMOD_LOOP_NORMAL : FMOD_LOOP_OFF)  | FMOD_2D);
+		result = Owner->Sys->playSound(Stream,0, true, &Channel);
+		if (result != FMOD_OK)
+		{
+			return false;
+		}
+		Channel->setChannelGroup(Owner->MusicGroup);
+		Channel->setMixLevelsOutput(1, 1, 1, 1, 1, 1, 1, 1);
+		Channel->setVolume(volume);
+		// Ensure reverb is disabled.
+		Channel->setReverbProperties(0,-10000);
+
+		Channel->setPaused(false);
+		Ended = false;
+		JustStarted = true;
+		Starved = false;
+		Loop = looping;
+		Volume = volume;
+		return true;
+	}
+
+	void Stop()
+	{
+		if (Channel != NULL)
+		{
+			Channel->stop();
+			Channel = NULL;
+		}
+	}
+
+	bool SetPaused(bool paused)
+	{
+		if (Channel != NULL)
+		{
+			return FMOD_OK == Channel->setPaused(paused);
+		}
+		return false;
+	}
+
+	unsigned int GetPosition()
+	{
+		unsigned int pos;
+
+		if (Channel != NULL && FMOD_OK == Channel->getPosition(&pos, FMOD_TIMEUNIT_MS))
+		{
+			return pos;
+		}
+		return 0;
+	}
+
+	bool IsEnded()
+	{
+		bool is;
+		FMOD_OPENSTATE openstate = FMOD_OPENSTATE_MAX;
+		bool starving;
+
+		bool diskbusy;
+
+
+		if (Stream == NULL)
+		{
+			return true;
+		}
+
+		if (FMOD_OK != Stream->getOpenState(&openstate, NULL, &starving, &diskbusy))
+		{
+			openstate = FMOD_OPENSTATE_ERROR;
+		}
+		if (openstate == FMOD_OPENSTATE_ERROR)
+		{
+			if (Channel != NULL)
+			{
+				Channel->stop();
+				Channel = NULL;
+			}
+			return true;
+		}
+		if (Channel != NULL && (FMOD_OK != Channel->isPlaying(&is) || is == false))
+		{
+			return true;
+		}
+		if (Ended)
+		{
+			Channel->stop();
+			Channel = NULL;
+			return true;
+		}
+		if (URL.IsNotEmpty() && !JustStarted && openstate == FMOD_OPENSTATE_READY)
+		{
+			// Reconnect the stream, since it seems to have stalled.
+			// The only way to do this appears to be to completely recreate it.
+			FMOD_RESULT result;
+
+			Channel->stop();
+			Stream->release();
+			Channel = NULL;
+			Stream = NULL;
+			Owner->Sys->setStreamBufferSize(64*1024, FMOD_TIMEUNIT_RAWBYTES);
+			// Open the stream asynchronously, so we don't hang the game while trying to reconnect.
+			// (It would be nice to do the initial open asynchronously as well, but I'd need to rethink
+			// the music system design to pull that off.)
+			result = Owner->Sys->createSound(URL, (Loop ? FMOD_LOOP_NORMAL : FMOD_LOOP_OFF)  | FMOD_2D |
+					FMOD_CREATESTREAM | FMOD_NONBLOCKING, NULL, &Stream);
+			JustStarted = true;
+			Owner->Sys->setStreamBufferSize(16*1024, FMOD_TIMEUNIT_RAWBYTES);
+			return result != FMOD_OK;
+		}
+		if (JustStarted && openstate == FMOD_OPENSTATE_PLAYING)
+		{
+			JustStarted = false;
+		}
+		if (JustStarted && Channel == NULL && openstate == FMOD_OPENSTATE_READY)
+		{
+			return !Play(Loop, Volume);
+		}
+		if (starving != Starved)
+		{ // Mute the sound if it's starving.
+			Channel->setVolume(starving ? 0 : Volume);
+			Starved = starving;
+		}
+		return false;
+	}
+
+	void SetVolume(float volume)
+	{
+		if (Channel != NULL && !Starved)
+		{
+			Channel->setVolume(volume);
+		}
+		Volume = volume;
+	}
+
+	// Sets the position in ms.
+	bool SetPosition(unsigned int ms_pos)
+	{
+		return FMOD_OK == Channel->setPosition(ms_pos, FMOD_TIMEUNIT_MS);
+	}
+
+	// Sets the order number for MOD formats.
+	bool SetOrder(int order_pos)
+	{
+		return FMOD_OK == Channel->setPosition(order_pos, FMOD_TIMEUNIT_MODORDER);
+	}
+
+	FString GetStats()
+	{
+		FString stats;
+		FMOD_OPENSTATE openstate;
+		unsigned int percentbuffered;
+		unsigned int position;
+		bool starving;
+
+		bool diskbusy;
+
+		float volume;
+		float frequency;
+		bool paused;
+		bool isplaying;
+
+
+		if (FMOD_OK == Stream->getOpenState(&openstate, &percentbuffered, &starving, &diskbusy))
+		{
+			stats = (openstate <= FMOD_OPENSTATE_PLAYING ? OpenStateNames[openstate] : "Unknown state");
+			stats.AppendFormat(",%3d%% buffered, %s", percentbuffered, starving ? "Starving" : "Well-fed");
+		}
+		if (Channel == NULL)
+		{
+			stats += ", not playing";
+		}
+		if (Channel != NULL && FMOD_OK == Channel->getPosition(&position, FMOD_TIMEUNIT_MS))
+		{
+			stats.AppendFormat(", %d", position);
+			if (FMOD_OK == Stream->getLength(&position, FMOD_TIMEUNIT_MS))
+			{
+				stats.AppendFormat("/%d", position);
+			}
+			stats += " ms";
+		}
+		if (Channel != NULL && FMOD_OK == Channel->getVolume(&volume))
+		{
+			stats.AppendFormat(", %d%%", int(volume * 100));
+		}
+		if (Channel != NULL && FMOD_OK == Channel->getPaused(&paused) && paused)
+		{
+			stats += ", paused";
+		}
+		if (Channel != NULL && FMOD_OK == Channel->isPlaying(&isplaying) && isplaying)
+		{
+			stats += ", playing";
+		}
+		if (Channel != NULL && FMOD_OK == Channel->getFrequency(&frequency))
+		{
+			stats.AppendFormat(", %g Hz", frequency);
+		}
+		if (JustStarted)
+		{
+			stats += " JS";
+		}
+		if (Ended)
+		{
+			stats += " XX";
+		}
+		return stats;
+	}
+
+	static FMOD_RESULT F_CALLBACK PCMReadCallback(FMOD_SOUND *sound, void *data, unsigned int datalen)
+	{
+		FMOD_RESULT result;
+		FMODStreamCapsule *self;
+
+		result = ((FMOD::Sound *)sound)->getUserData((void **)&self);
+		if (result != FMOD_OK || self == NULL || self->Callback == NULL || self->Ended)
+		{
+			// Contrary to the docs, this return value is completely ignored.
+			return FMOD_OK;
+		}
+		if (!self->Callback(self, data, datalen, self->UserData))
+		{
+			self->Ended = true;
+		}
+		return FMOD_OK;
+	}
+
+	static FMOD_RESULT F_CALLBACK PCMSetPosCallback(FMOD_SOUND *sound, int subsound, unsigned int position, FMOD_TIMEUNIT postype)
+	{
+		// This is useful if the user calls Channel::setPosition and you want
+		// to seek your data accordingly.
+		return FMOD_OK;
+	}
+
+private:
+	FMODSoundRenderer *Owner;
+	FMOD::Sound *Stream;
+	FMOD::Channel *Channel;
+	void *UserData;
+	SoundStreamCallback Callback;
+	FString URL;
+	bool Ended;
+	bool JustStarted;
+	bool Starved;
+	bool Loop;
+	float Volume;
+};
+
+//==========================================================================
+//
+// The interface the game uses to talk to FMOD.
+//
+//==========================================================================
+
+FMODSoundRenderer::FMODSoundRenderer()
+{
+	InitSuccess = Init();
+}
+
+FMODSoundRenderer::~FMODSoundRenderer()
+{
+	Shutdown();
+}
+
+bool FMODSoundRenderer::IsValid()
+{
+	return InitSuccess;
+}
+
+#ifdef _MSC_VER
+//==========================================================================
+//
+// CheckException
+//
+//==========================================================================
+
+#define FACILITY_VISUALCPP  ((LONG)0x6d)
+#define VcppException(sev,err)  ((sev) | (FACILITY_VISUALCPP<<16) | err)
+
+static int CheckException(DWORD code)
+{
+	if (code == VcppException(ERROR_SEVERITY_ERROR,ERROR_MOD_NOT_FOUND) ||
+			code == VcppException(ERROR_SEVERITY_ERROR,ERROR_PROC_NOT_FOUND))
+	{
+		return EXCEPTION_EXECUTE_HANDLER;
+	}
+	return EXCEPTION_CONTINUE_SEARCH;
+}
+
+#endif
+
+//==========================================================================
+//
+// FMODSoundRenderer :: Init
+//
+//==========================================================================
+
+bool FMODSoundRenderer::Init()
+{
+	FMOD_RESULT result;
+	unsigned int version;
+	FMOD_SPEAKERMODE speakermode;
+	FMOD_SOUND_FORMAT format;
+	FMOD_DSP_RESAMPLER resampler;
+	FMOD_INITFLAGS initflags;
+	int samplerate;
+	int driver;
+
+	int eval;
+
+	SFXPaused = 0;
+	DSPLocked = false;
+	MusicGroup = NULL;
+	SfxGroup = NULL;
+	PausableSfx = NULL;
+	SfxConnection = NULL;
+	WaterLP = NULL;
+	WaterReverb = NULL;
+	PrevEnvironment = DefaultEnvironments[0];
+	DSPClock.AsOne = 0;
+	ChannelGroupTargetUnit = NULL;
+	ChannelGroupTargetUnitOutput = NULL;
+	SfxReverbHooked = false;
+	SfxReverbPlaceholder = NULL;
+	OutputPlugin = 0;
+
+	Printf("I_InitSound: Initializing FMOD\n");
+
+	// Create a System object and initialize.
+#ifdef _MSC_VER
+	__try {
+#endif
+		result = FMOD::System_Create(&Sys);
+#ifdef _MSC_VER
+	}
+	__except(CheckException(GetExceptionCode()))
+	{
+		Sys = NULL;
+		Printf(TEXTCOLOR_ORANGE"Failed to load fmodex"
+#ifdef _WIN64
+				"64"
+#endif
+				".dll\n");
+		return false;
+	}
+#endif
+	if (result != FMOD_OK)
+	{
+		Sys = NULL;
+		Printf(TEXTCOLOR_ORANGE"Failed to create FMOD system object: Error %d\n", result);
+		return false;
+	}
+
+	result = Sys->getVersion(&version);
+	if (result != FMOD_OK)
+	{
+		Printf(TEXTCOLOR_ORANGE"Could not validate FMOD version: Error %d\n", result);
+		return false;
+	}
+
+	const char *wrongver = NULL;
+	/*
+#if FMOD_VERSION >= 0x43800
+	if (version < 0x43800)
+#else
+	if (version < 0x42000)
+#endif
+	{
+		wrongver = "an old";
+	}
+#if FMOD_VERSION < 0x42700
+	else if ((version & 0xFFFF00) > 0x42600)
+#else
+	else if ((version & 0xFFFF00) > (FMOD_VERSION & 0xFFFF00))
+#endif
+	{
+		wrongver = "a new";
+	}
+	if (wrongver != NULL)
+	{
+		Printf (" " TEXTCOLOR_ORANGE "Error! You are using %s version of FMOD (%x.%02x.%02x).\n"
+				" " TEXTCOLOR_ORANGE "This program was built for version %x.%02x.%02x\n",
+				wrongver,
+				version >> 16, (version >> 8) & 255, version & 255,
+				FMOD_VERSION >> 16, (FMOD_VERSION >> 8) & 255, FMOD_VERSION & 255);
+		return false;
+	}
+	 */
+	ActiveFMODVersion = version;
+
+	if (!ShowedBanner)
+	{
+		// '\xa9' is the copyright symbol in the Windows-1252 code page.
+		Printf("FMOD Sound System, copyright \xa9 Firelight Technologies Pty, Ltd., 1994-2009.\n");
+		Printf("Loaded FMOD version %x.%02x.%02x\n", version >> 16, (version >> 8) & 255, version & 255);
+		ShowedBanner = true;
+	}
+#ifdef _WIN32
+	if (OSPlatform == os_WinNT4)
+	{
+		// The following was true as of FMOD 3. I don't know if it still
+		// applies to FMOD Ex, nor do I have an NT 4 install anymore, but
+		// there's no reason to get rid of it yet.
+		//
+		// If running Windows NT 4, we need to initialize DirectSound before
+		// using WinMM. If we don't, then FSOUND_Close will corrupt a
+		// heap. This might just be the Audigy's drivers--I don't know why
+		// it happens. At least the fix is simple enough. I only need to
+		// initialize DirectSound once, and then I can initialize/close
+		// WinMM as many times as I want.
+		//
+		// Yes, using WinMM under NT 4 is a good idea. I can get latencies as
+		// low as 20 ms with WinMM, but with DirectSound I need to have the
+		// latency as high as 120 ms to avoid crackling--quite the opposite
+		// from the other Windows versions with real DirectSound support.
+
+		static bool inited_dsound = false;
+
+		if (!inited_dsound)
+		{
+			if (Sys->setOutput(FMOD_OUTPUTTYPE_DSOUND) == FMOD_OK)
+			{
+				if (Sys->init(1, FMOD_INIT_NORMAL, 0) == FMOD_OK)
+				{
+					inited_dsound = true;
+					Sleep(50);
+					Sys->close();
+				}
+				Sys->setOutput(FMOD_OUTPUTTYPE_WINMM);
+			}
+		}
+	}
+#endif
+
+#ifndef _WIN32
+	// Try to load SDL output plugin
+	result = Sys->setPluginPath(progdir);	// Should we really look for it in the program directory?
+	result = Sys->loadPlugin("liboutput_sdl.so", &OutputPlugin);
+	if (result != FMOD_OK)
+	{
+		OutputPlugin = 0;
+	}
+#endif
+
+	// Set the user specified output mode.
+	eval = Enum_NumForName(OutputNames, snd_output);
+	if (eval >= 0)
+	{
+		if (eval == 666 && OutputPlugin != 0)
+		{
+			result = Sys->setOutputByPlugin(OutputPlugin);
+		}
+		else
+		{
+			result = Sys->setOutput(FMOD_OUTPUTTYPE(eval));
+		}
+		if (result != FMOD_OK)
+		{
+			Printf(TEXTCOLOR_BLUE"Setting output type '%s' failed. Using default instead. (Error %d)\n", *snd_output, result);
+			eval = FMOD_OUTPUTTYPE_AUTODETECT;
+			Sys->setOutput(FMOD_OUTPUTTYPE_AUTODETECT);
+		}
+	}
+
+#ifdef __ANDROID__
+	result = Sys->setOutput(FMOD_OUTPUTTYPE_OPENSL);
+#endif
+
+	result = Sys->getNumDrivers(&driver);
+	/*
+#ifdef __unix__
+	if (result == FMOD_OK)
+	{
+		// On Linux, FMOD defaults to OSS. If OSS is not present, it doesn't
+		// try ALSA; it just fails. We'll try for it, but only if OSS wasn't
+		// explicitly specified for snd_output.
+		if (driver == 0 && eval == FMOD_OUTPUTTYPE_AUTODETECT)
+		{
+			FMOD_OUTPUTTYPE output;
+			if (FMOD_OK == Sys->getOutput(&output))
+			{
+				if (output == FMOD_OUTPUTTYPE_OSS)
+				{
+					Printf(TEXTCOLOR_BLUE"OSS could not be initialized. Trying ALSA.\n");
+					Sys->setOutput(FMOD_OUTPUTTYPE_ALSA);
+					result = Sys->getNumDrivers(&driver);
+				}
+			}
+		}
+	}
+#endif
+	 */
+	if (result == FMOD_OK)
+	{
+		if (driver == 0)
+		{
+			Printf(TEXTCOLOR_ORANGE"No working sound devices found. Try a different snd_output?\n");
+			return false;
+		}
+		if (snd_driver >= driver)
+		{
+			Printf(TEXTCOLOR_BLUE"Driver %d does not exist. Using 0.\n", *snd_driver);
+			driver = 0;
+		}
+		else
+		{
+			driver = snd_driver;
+		}
+		result = Sys->setDriver(driver);
+	}
+	result = Sys->getDriver(&driver);
+
+	//result = -1;
+#ifndef NO_FMOD_CAPS_FIX_ME
+#if FMOD_VERSION >= 0x43700
+	// We were built with an FMOD that only returns the control panel frequency
+	result = Sys->getDriverCaps(driver, &Driver_Caps, &Driver_MinFrequency, &speakermode);
+	Driver_MaxFrequency = Driver_MinFrequency;
+#else
+	// We were built with an FMOD that returns a frequency range
+	result = Sys->getDriverCaps(driver, &Driver_Caps, &Driver_MinFrequency, &Driver_MaxFrequency, &speakermode);
+#endif
+#endif
+	if (result != FMOD_OK)
+	{
+		Printf(TEXTCOLOR_BLUE"Could not ascertain driver capabilities. Some things may be weird. (Error %d)\n", result);
+		// Fill in some default to pretend it worked. (But as long as we specify a valid driver,
+		// can this call actually fail?)
+#ifndef NO_FMOD_CAPS_FIX_ME
+		Driver_Caps = 0;
+		Driver_MinFrequency = 4000;
+		Driver_MaxFrequency = 48000;
+#endif
+		speakermode = FMOD_SPEAKERMODE_STEREO;
+	}
+
+	// Set the user selected speaker mode.
+	eval = Enum_NumForName(SpeakerModeNames, snd_speakermode);
+	if (eval >= 0)
+	{
+		speakermode = FMOD_SPEAKERMODE(eval);
+	}
+	speakermode = FMOD_SPEAKERMODE_DEFAULT;
+
+	// Set software format
+	eval = Enum_NumForName(SoundFormatNames, snd_output_format);
+	format = eval >= 0 ? FMOD_SOUND_FORMAT(eval) : FMOD_SOUND_FORMAT_PCM16;
+	eval = Enum_NumForName(ResamplerNames, snd_resampler);
+	resampler = eval >= 0 ? FMOD_DSP_RESAMPLER(eval) : FMOD_DSP_RESAMPLER_LINEAR;
+	// These represented the frequency limits for hardware channels, which we never used anyway.
+	//	samplerate = clamp<int>(snd_samplerate, Driver_MinFrequency, Driver_MaxFrequency);
+	samplerate = snd_samplerate;
+	if (samplerate == 0 || snd_samplerate == 0)
+	{ // Creative's ASIO drivers report the only supported frequency as 0!
+		if (FMOD_OK != Sys->getSoftwareFormat(&samplerate, NULL, NULL))
+		{
+			samplerate = 48000;
+		}
+	}
+	if (samplerate != snd_samplerate && snd_samplerate != 0)
+	{
+		Printf(TEXTCOLOR_BLUE"Sample rate %d is unsupported. Trying %d.\n", *snd_samplerate, samplerate);
+	}
+
+#ifdef __ANDROID__
+	samplerate =  snd_samplerate;
+	if (samplerate < 22050)
+		samplerate = 22050;
+	//samplerate = 22050; //Force this for now, less CPU?
+#endif
+	Printf(TEXTCOLOR_BLUE"Fmod Sample rate set to %d\n",samplerate);
+	result = Sys->setSoftwareFormat(samplerate, speakermode, 0);
+	if (result != FMOD_OK)
+	{
+		Printf(TEXTCOLOR_BLUE"Could not set mixing format. Defaults will be used. (Error %d)\n", result);
+	}
+
+	// Set software channels according to snd_channels
+	result = Sys->setSoftwareChannels(snd_channels + NUM_EXTRA_SOFTWARE_CHANNELS);
+	if (result != FMOD_OK)
+	{
+		Printf(TEXTCOLOR_BLUE"Failed to set the preferred number of channels. (Error %d)\n", result);
+	}
+
+	if (snd_buffersize != 0 || snd_buffercount != 0)
+	{
+		int buffersize = snd_buffersize ? snd_buffersize : 1024;
+		int buffercount = snd_buffercount ? snd_buffercount : 4;
+		result = Sys->setDSPBufferSize(buffersize, buffercount);
+	}
+	else
+	{
+		result = FMOD_OK;
+	}
+	if (result != FMOD_OK)
+	{
+		Printf(TEXTCOLOR_BLUE"Setting DSP buffer size failed. (Error %d)\n", result);
+	}
+
+	// Try to init
+	initflags = FMOD_INIT_NORMAL;
+	if (snd_hrtf)
+	{
+		// These flags are the same thing, just with different names.
+		initflags |= FMOD_INIT_CHANNEL_LOWPASS;
+	}
+	if (snd_profile)
+	{
+		initflags |= FMOD_INIT_PROFILE_METER_ALL;
+	}
+	for (;;)
+	{
+		//result = Sys->init(MAX(*snd_channels, MAX_CHANNELS), initflags, 0);
+		result = Sys->init(128, FMOD_INIT_NORMAL, 0);
+		Printf(TEXTCOLOR_RED"  Sys->init returned %d\n",result);
+		if (result == FMOD_ERR_OUTPUT_CREATEBUFFER)
+		{ 
+			Printf(TEXTCOLOR_RED"  Buffer creation failed.\n");
+			/* TO BE FIXED
+			// Possible causes of a buffer creation failure:
+			// 1. The speaker mode selected isn't supported by this soundcard. Force it to stereo.
+			// 2. The output format is unsupported. Force it to 16-bit PCM.
+			// 3. ???
+			result = Sys->GetSoftwareFormat(NULL,&speakermode,NULL);
+			if (result == FMOD_OK &&
+				speakermode != FMOD_SPEAKERMODE_STEREO &&
+				FMOD_OK == Sys->setSpeakerMode(FMOD_SPEAKERMODE_STEREO))
+			{
+				Printf(TEXTCOLOR_RED"  Buffer creation failed. Retrying with stereo output.\n");
+				continue;
+			}
+			result = Sys->getSoftwareFormat(&samplerate, &format, NULL, NULL, &resampler, NULL);
+			if (result == FMOD_OK &&
+				format != FMOD_SOUND_FORMAT_PCM16 &&
+				FMOD_OK == Sys->setSoftwareFormat(samplerate, FMOD_SOUND_FORMAT_PCM16, 0, 0, resampler))
+			{
+				Printf(TEXTCOLOR_RED"  Buffer creation failed. Retrying with PCM-16 output.\n");
+				continue;
+			}
+			 */
+		}
+		else if (result == FMOD_ERR_NET_SOCKET_ERROR && (initflags & FMOD_INIT_PROFILE_METER_ALL))
+		{
+			Printf(TEXTCOLOR_RED"  Could not create socket. Retrying without profiling.\n");
+			initflags &= ~FMOD_INIT_PROFILE_METER_ALL;
+			continue;
+		}
+#ifdef _WIN32
+		else if (result == FMOD_ERR_OUTPUT_INIT)
+		{
+			FMOD_OUTPUTTYPE output;
+			result = Sys->getOutput(&output);
+			if (result == FMOD_OK && output != FMOD_OUTPUTTYPE_DSOUND)
+			{
+				Printf(TEXTCOLOR_BLUE"  Init failed for output type %s. Retrying with DirectSound.\n",
+						Enum_NameForNum(OutputNames, output));
+				if (FMOD_OK == Sys->setOutput(FMOD_OUTPUTTYPE_DSOUND))
+				{
+					continue;
+				}
+			}
+		}
+#endif
+		break;
+	}
+	if (result != FMOD_OK)
+	{ // Initializing FMOD failed. Cry cry.
+		Printf(TEXTCOLOR_ORANGE"  System::init returned error code %d\n", result);
+		return false;
+	}
+
+	// Create channel groups
+	result = Sys->createChannelGroup("Music", &MusicGroup);
+	if (result != FMOD_OK)
+	{
+		Printf(TEXTCOLOR_ORANGE"  Could not create music channel group. (Error %d)\n", result);
+		return false;
+	}
+
+	result = Sys->createChannelGroup("SFX", &SfxGroup);
+	if (result != FMOD_OK)
+	{
+		Printf(TEXTCOLOR_ORANGE"  Could not create sfx channel group. (Error %d)\n", result);
+		return false;
+	}
+
+	result = Sys->createChannelGroup("Pausable SFX", &PausableSfx);
+	if (result != FMOD_OK)
+	{
+		Printf(TEXTCOLOR_ORANGE"  Could not create pausable sfx channel group. (Error %d)\n", result);
+		return false;
+	}
+
+	result = SfxGroup->addGroup(PausableSfx);
+	if (result != FMOD_OK)
+	{
+		Printf(TEXTCOLOR_BLUE"  Could not attach pausable sfx to sfx channel group. (Error %d)\n", result);
+	}
+
+
+	result = FMOD_ERR_UNSUPPORTED;
+
+
+	// Connect underwater DSP unit between PausableSFX and SFX groups, while
+	// retaining the connection established by SfxGroup->addGroup().
+	if (WaterLP != NULL)
+	{
+		FMOD::DSP *sfx_head, *pausable_head;
+
+		int nbrdsp;
+		SfxGroup->getNumDSPs(&nbrdsp);
+		result = SfxGroup->getDSP(nbrdsp-1,&sfx_head);
+		if (result == FMOD_OK)
+		{
+			result = sfx_head->getInput(0, &pausable_head, &SfxConnection);
+			if (result == FMOD_OK)
+			{
+				// The placeholder mixer is for reference to where to connect the SFX
+				// reverb unit once it gets created.
+				result = Sys->createDSPByType(FMOD_DSP_TYPE_MIXER, &SfxReverbPlaceholder);
+				if (result == FMOD_OK)
+				{
+					// Replace the PausableSFX->SFX connection with
+					// PausableSFX->ReverbPlaceholder->SFX.
+					result = SfxReverbPlaceholder->addInput(pausable_head, NULL);
+					if (result == FMOD_OK)
+					{
+						FMOD::DSPConnection *connection;
+						result = sfx_head->addInput(SfxReverbPlaceholder, &connection);
+						if (result == FMOD_OK)
+						{
+							sfx_head->disconnectFrom(pausable_head);
+							SfxReverbPlaceholder->setActive(true);
+							SfxReverbPlaceholder->setBypass(true);
+							// The placeholder now takes the place of the pausable_head
+							// for the following connections.
+							pausable_head = SfxReverbPlaceholder;
+							SfxConnection = connection;
+						}
+					}
+					else
+					{
+						SfxReverbPlaceholder->release();
+						SfxReverbPlaceholder = NULL;
+					}
+				}
+				result = WaterLP->addInput(pausable_head, NULL);
+				WaterLP->setActive(false);
+				WaterLP->setParameterFloat(FMOD_DSP_LOWPASS_CUTOFF, snd_waterlp);
+				WaterLP->setParameterFloat(FMOD_DSP_LOWPASS_RESONANCE, 2);
+
+				{
+					result = sfx_head->addInput(WaterLP, NULL);
+				}
+			}
+		}
+	}
+	LastWaterLP = snd_waterlp;
+
+	// Find the FMOD Channel Group Target Unit. To completely eliminate sound
+	// while the program is deactivated, we can deactivate this DSP unit, and
+	// all audio processing will cease. This is not directly exposed by the
+	// API but can be easily located by getting the master channel group and
+	// tracing its single output, since it is known to hook up directly to the
+	// Channel Group Target Unit. (See FMOD Profiler for proof.)
+	FMOD::ChannelGroup *master_group;
+	result = Sys->getMasterChannelGroup(&master_group);
+	if (result == FMOD_OK)
+	{
+		FMOD::DSP *master_head;
+		int nbrdsp;
+
+		result = master_group->getDSP(nbrdsp-1,&master_head);
+		if (result == FMOD_OK)
+		{
+			result = master_head->getOutput(0, &ChannelGroupTargetUnit, NULL);
+			if (result != FMOD_OK)
+			{
+				ChannelGroupTargetUnit = NULL;
+			}
+			else
+			{
+				FMOD::DSP *dontcare;
+				result = ChannelGroupTargetUnit->getOutput(0, &dontcare, &ChannelGroupTargetUnitOutput);
+				if (result != FMOD_OK)
+				{
+					ChannelGroupTargetUnitOutput = NULL;
+				}
+			}
+		}
+	}
+
+	if (FMOD_OK != Sys->getSoftwareFormat(&OutputRate, NULL, NULL))
+	{
+		OutputRate = 48000;		// Guess, but this should never happen.
+	}
+	Sys->set3DSettings(0.5f, 96.f, 1.f);
+	Sys->set3DRolloffCallback(RolloffCallback);
+	snd_sfxvolume.Callback ();
+	return true;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: Shutdown
+//
+//==========================================================================
+
+void FMODSoundRenderer::Shutdown()
+{
+	if (Sys != NULL)
+	{
+		if (MusicGroup != NULL)
+		{
+			MusicGroup->release();
+			MusicGroup = NULL;
+		}
+		if (PausableSfx != NULL)
+		{
+			PausableSfx->release();
+			PausableSfx = NULL;
+		}
+		if (SfxGroup != NULL)
+		{
+			SfxGroup->release();
+			SfxGroup = NULL;
+		}
+		if (WaterLP != NULL)
+		{
+			WaterLP->release();
+			WaterLP = NULL;
+		}
+		if (WaterReverb != NULL)
+		{
+			WaterReverb->release();
+			WaterReverb = NULL;
+		}
+		if (SfxReverbPlaceholder != NULL)
+		{
+			SfxReverbPlaceholder->release();
+			SfxReverbPlaceholder = NULL;
+		}
+
+		Sys->close();
+		if (OutputPlugin != 0)
+		{
+			Sys->unloadPlugin(OutputPlugin);
+			OutputPlugin = 0;
+		}
+		Sys->release();
+		Sys = NULL;
+	}
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: GetOutputRate
+//
+//==========================================================================
+
+float FMODSoundRenderer::GetOutputRate()
+{
+	return (float)OutputRate;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: PrintStatus
+//
+//==========================================================================
+
+void FMODSoundRenderer::PrintStatus()
+{
+	FMOD_OUTPUTTYPE output;
+	FMOD_SPEAKERMODE speakermode;
+	FMOD_SOUND_FORMAT format;
+	FMOD_DSP_RESAMPLER resampler;
+	int driver;
+	int samplerate;
+	int numoutputchannels;
+	unsigned int bufferlength;
+	int numbuffers;
+
+	Printf ("Loaded FMOD version: " TEXTCOLOR_GREEN "%x.%02x.%02x\n", ActiveFMODVersion >> 16,
+			(ActiveFMODVersion >> 8) & 255, ActiveFMODVersion & 255);
+	if (FMOD_OK == Sys->getOutput(&output))
+	{
+		Printf ("Output type: " TEXTCOLOR_GREEN "%s\n", Enum_NameForNum(OutputNames, output));
+	}
+	if (FMOD_OK == Sys->getSoftwareFormat(NULL,&speakermode,NULL))
+	{
+		Printf ("Speaker mode: " TEXTCOLOR_GREEN "%s\n", Enum_NameForNum(SpeakerModeNames, speakermode));
+	}
+	if (FMOD_OK == Sys->getDriver(&driver))
+	{
+		char name[256];
+		if (FMOD_OK != Sys->getDriverInfo(driver, name, sizeof(name), NULL,NULL,NULL,NULL))
+		{
+			strcpy(name, "Unknown");
+		}
+		Printf ("Driver: " TEXTCOLOR_GREEN "%d" TEXTCOLOR_NORMAL " (" TEXTCOLOR_ORANGE "%s" TEXTCOLOR_NORMAL ")\n", driver, name);
+
+		//	(Driver_Caps, Driver_MinFrequency, Driver_MaxFrequency);
+	}
+	if (FMOD_OK == Sys->getSoftwareFormat(&samplerate,  NULL,  NULL)) //TODO FIX THIS
+	{
+		Printf (TEXTCOLOR_LIGHTBLUE "Software mixer sample rate: " TEXTCOLOR_GREEN "%d\n", samplerate);
+		Printf (TEXTCOLOR_LIGHTBLUE "Software mixer format: " TEXTCOLOR_GREEN "%s\n", Enum_NameForNum(SoundFormatNames, format));
+		Printf (TEXTCOLOR_LIGHTBLUE "Software mixer channels: " TEXTCOLOR_GREEN "%d\n", numoutputchannels);
+		Printf (TEXTCOLOR_LIGHTBLUE "Software mixer resampler: " TEXTCOLOR_GREEN "%s\n", Enum_NameForNum(ResamplerNames, resampler));
+	}
+	if (FMOD_OK == Sys->getDSPBufferSize(&bufferlength, &numbuffers))
+	{
+		Printf (TEXTCOLOR_LIGHTBLUE "DSP buffers: " TEXTCOLOR_GREEN "%u samples x %d\n", bufferlength, numbuffers);
+	}
+}
+#ifndef NO_FMOD_CAPS_FIX_ME
+//==========================================================================
+//
+// FMODSoundRenderer :: DumpDriverCaps
+//
+//==========================================================================
+
+void FMODSoundRenderer::DumpDriverCaps(FMOD_CAPS caps, int minfrequency, int maxfrequency)
+{
+	Printf (TEXTCOLOR_OLIVE "   Min. frequency: " TEXTCOLOR_GREEN "%d\n", minfrequency);
+	Printf (TEXTCOLOR_OLIVE "   Max. frequency: " TEXTCOLOR_GREEN "%d\n", maxfrequency);
+	Printf ("  Features:\n");
+	if (caps == 0)									Printf(TEXTCOLOR_OLIVE "   None\n");
+	if (caps & FMOD_CAPS_HARDWARE)					Printf(TEXTCOLOR_OLIVE "   Hardware mixing\n");
+	if (caps & FMOD_CAPS_HARDWARE_EMULATED)			Printf(TEXTCOLOR_OLIVE "   Hardware acceleration is turned off!\n");
+	if (caps & FMOD_CAPS_OUTPUT_MULTICHANNEL)		Printf(TEXTCOLOR_OLIVE "   Multichannel\n");
+	if (caps & FMOD_CAPS_OUTPUT_FORMAT_PCM8)		Printf(TEXTCOLOR_OLIVE "   PCM-8");
+	if (caps & FMOD_CAPS_OUTPUT_FORMAT_PCM16)		Printf(TEXTCOLOR_OLIVE "   PCM-16");
+	if (caps & FMOD_CAPS_OUTPUT_FORMAT_PCM24)		Printf(TEXTCOLOR_OLIVE "   PCM-24");
+	if (caps & FMOD_CAPS_OUTPUT_FORMAT_PCM32)		Printf(TEXTCOLOR_OLIVE "   PCM-32");
+	if (caps & FMOD_CAPS_OUTPUT_FORMAT_PCMFLOAT)	Printf(TEXTCOLOR_OLIVE "   PCM-Float");
+	if (caps & (FMOD_CAPS_OUTPUT_FORMAT_PCM8 | FMOD_CAPS_OUTPUT_FORMAT_PCM16 | FMOD_CAPS_OUTPUT_FORMAT_PCM24 | FMOD_CAPS_OUTPUT_FORMAT_PCM32 | FMOD_CAPS_OUTPUT_FORMAT_PCMFLOAT))
+	{
+		Printf("\n");
+	}
+	if (caps & FMOD_CAPS_REVERB_LIMITED)			Printf(TEXTCOLOR_OLIVE "   Limited reverb\n");
+}
+#endif
+//==========================================================================
+//
+// FMODSoundRenderer :: PrintDriversList
+//
+//==========================================================================
+
+void FMODSoundRenderer::PrintDriversList()
+{
+	int numdrivers;
+	int i;
+	char name[256];
+
+	if (FMOD_OK == Sys->getNumDrivers(&numdrivers))
+	{
+		for (i = 0; i < numdrivers; ++i)
+		{
+			if (FMOD_OK == Sys->getDriverInfo(i, name,sizeof(name), NULL,NULL,NULL,NULL))
+			{
+				Printf("%d. %s\n", i, name);
+			}
+		}
+	}
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: GatherStats
+//
+//==========================================================================
+
+FString FMODSoundRenderer::GatherStats()
+{
+	int channels;
+	float dsp, stream, update, geometry, total;
+	FString out;
+
+	channels = 0;
+	total = update = geometry = stream = dsp = 0;
+	Sys->getChannelsPlaying(&channels);
+
+	// We were built with an FMOD with the geometry parameter.
+	if (ActiveFMODVersion >= 0x42501)
+	{ // And we are running with an FMOD that includes it.
+		FMOD_System_GetCPUUsage((FMOD_SYSTEM *)Sys, &dsp, &stream, &geometry, &update, &total);
+	}
+	else
+	{ // And we are running with an FMOD that does not include it.
+		// Cast the function to the appropriate type and call through the cast,
+		// since the headers are for the newer version.
+		((FMOD_RESULT (F_API *)(FMOD_SYSTEM *, float *, float *, float *, float *))
+				FMOD_System_GetCPUUsage)((FMOD_SYSTEM *)Sys, &dsp, &stream, &update, &total);
+	}
+
+
+	out.Format ("%d channels," TEXTCOLOR_YELLOW "%5.2f" TEXTCOLOR_NORMAL "%% CPU "
+			"(DSP:" TEXTCOLOR_YELLOW "%5.2f" TEXTCOLOR_NORMAL "%% "
+			"Stream:" TEXTCOLOR_YELLOW "%5.2f" TEXTCOLOR_NORMAL "%% "
+			"Geometry:" TEXTCOLOR_YELLOW "%5.2f" TEXTCOLOR_NORMAL "%% "
+			"Update:" TEXTCOLOR_YELLOW "%5.2f" TEXTCOLOR_NORMAL "%%)",
+			channels, total, dsp, stream, geometry, update);
+	return out;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: SetSfxVolume
+//
+//==========================================================================
+
+void FMODSoundRenderer::SetSfxVolume(float volume)
+{
+	SfxGroup->setVolume(volume);
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: SetMusicVolume
+//
+//==========================================================================
+
+void FMODSoundRenderer::SetMusicVolume(float volume)
+{
+	MusicGroup->setVolume(volume);
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: CreateStream
+//
+// Creates a streaming sound that receives PCM data through a callback.
+//
+//==========================================================================
+
+SoundStream *FMODSoundRenderer::CreateStream (SoundStreamCallback callback, int buffbytes, int flags, int samplerate, void *userdata)
+{
+	FMODStreamCapsule *capsule;
+	FMOD::Sound *sound;
+	FMOD_RESULT result;
+	FMOD_CREATESOUNDEXINFO exinfo;
+	FMOD_MODE mode;
+	int sample_shift;
+	int channel_shift;
+
+	InitCreateSoundExInfo(&exinfo);
+	capsule = new FMODStreamCapsule (userdata, callback, this);
+
+	mode = FMOD_2D | FMOD_OPENUSER | FMOD_LOOP_NORMAL | FMOD_CREATESTREAM | FMOD_OPENONLY;
+	sample_shift = (flags & (SoundStream::Bits32 | SoundStream::Float)) ? 2 : (flags & SoundStream::Bits8) ? 0 : 1;
+	channel_shift = (flags & SoundStream::Mono) ? 0 : 1;
+
+	// Chunk size of stream update in samples. This will be the amount of data
+	// passed to the user callback.
+	exinfo.decodebuffersize	 = buffbytes >> (sample_shift + channel_shift);
+
+	// Number of channels in the sound.
+	exinfo.numchannels		 = 1 << channel_shift;
+
+	// Length of PCM data in bytes of whole song (for Sound::getLength).
+	// This pretends it's extremely long.
+	exinfo.length			 = ~0u;
+
+	// Default playback rate of sound. */
+	exinfo.defaultfrequency	 = samplerate;
+
+	// Data format of sound.
+	if (flags & SoundStream::Float)
+	{
+		exinfo.format = FMOD_SOUND_FORMAT_PCMFLOAT;
+	}
+	else if (flags & SoundStream::Bits32)
+	{
+		exinfo.format = FMOD_SOUND_FORMAT_PCM32;
+	}
+	else if (flags & SoundStream::Bits8)
+	{
+		exinfo.format = FMOD_SOUND_FORMAT_PCM8;
+	}
+	else
+	{
+		exinfo.format = FMOD_SOUND_FORMAT_PCM16;
+	}
+
+	// User callback for reading.
+	exinfo.pcmreadcallback	 = FMODStreamCapsule::PCMReadCallback;
+
+	// User callback for seeking.
+	exinfo.pcmsetposcallback = FMODStreamCapsule::PCMSetPosCallback;
+
+	// User data to be attached to the sound during creation.  Access via Sound::getUserData.
+	exinfo.userdata = capsule;
+
+	result = Sys->createSound(NULL, mode, &exinfo, &sound);
+	if (result != FMOD_OK)
+	{
+		delete capsule;
+		return NULL;
+	}
+	capsule->SetStream(sound);
+	return capsule;
+}
+
+//==========================================================================
+//
+// GetTagData
+//
+// Checks for a string-type tag, and returns its data.
+//
+//==========================================================================
+
+const char *GetTagData(FMOD::Sound *sound, const char *tag_name)
+{
+	FMOD_TAG tag;
+
+	if (FMOD_OK == sound->getTag(tag_name, 0, &tag) &&
+			(tag.datatype == FMOD_TAGDATATYPE_STRING || tag.datatype == FMOD_TAGDATATYPE_STRING_UTF8))
+	{
+		return (const char *)tag.data;
+	}
+	return NULL;
+}
+
+//==========================================================================
+//
+// SetCustomLoopPts
+//
+// Sets up custom sound loops by checking for these tags:
+//    LOOP_START
+//    LOOP_END
+//    LOOP_BIDI
+//
+//==========================================================================
+
+static void SetCustomLoopPts(FMOD::Sound *sound)
+{
+#if 0
+	FMOD_TAG tag;
+	int numtags;
+	if (FMOD_OK == stream->getNumTags(&numtags, NULL))
+	{
+		for (int i = 0; i < numtags; ++i)
+		{
+			if (FMOD_OK == sound->getTag(NULL, i, &tag))
+			{
+				Printf("Tag %2d. %d %s = %s\n", i, tag.datatype, tag.name, tag.data);
+			}
+		}
+	}
+#endif
+	const char *tag_data;
+	unsigned int looppt[2];
+	bool looppt_as_samples[2], have_looppt[2] = { false };
+	static const char *const loop_tags[2] = { "LOOP_START", "LOOP_END" };
+
+	for (int i = 0; i < 2; ++i)
+	{
+		if (NULL != (tag_data = GetTagData(sound, loop_tags[i])))
+		{
+			if (S_ParseTimeTag(tag_data, &looppt_as_samples[i], &looppt[i]))
+			{
+				have_looppt[i] = true;
+			}
+			else
+			{
+				Printf("Invalid %s tag: '%s'\n", loop_tags[i], tag_data);
+			}
+		}
+	}
+	if (have_looppt[0] && !have_looppt[1])
+	{ // Have a start tag, but not an end tag: End at the end of the song.
+		have_looppt[1] = (FMOD_OK == sound->getLength(&looppt[1], FMOD_TIMEUNIT_PCM));
+		looppt_as_samples[1] = true;
+	}
+	else if (!have_looppt[0] && have_looppt[1])
+	{ // Have an end tag, but no start tag: Start at beginning of the song.
+		looppt[0] = 0;
+		looppt_as_samples[0] = true;
+		have_looppt[0] = true;
+	}
+	if (have_looppt[0] && have_looppt[1])
+	{ // Have both loop points: Try to set the loop.
+		FMOD_RESULT res = sound->setLoopPoints(
+				looppt[0], looppt_as_samples[0] ? FMOD_TIMEUNIT_PCM : FMOD_TIMEUNIT_MS,
+						looppt[1] - 1, looppt_as_samples[1] ? FMOD_TIMEUNIT_PCM : FMOD_TIMEUNIT_MS);
+		if (res != FMOD_OK)
+		{
+			Printf("Setting custom loop points failed. Error %d\n", res);
+		}
+	}
+	// Check for a bi-directional loop.
+	if (NULL != (tag_data = GetTagData(sound, "LOOP_BIDI")) &&
+			(stricmp(tag_data, "on") == 0 ||
+					stricmp(tag_data, "true") == 0 ||
+					stricmp(tag_data, "yes") == 0 ||
+					stricmp(tag_data, "1") == 0))
+	{
+		FMOD_MODE mode;
+		if (FMOD_OK == (sound->getMode(&mode)))
+		{
+			sound->setMode((mode & ~(FMOD_LOOP_OFF | FMOD_LOOP_NORMAL)) | FMOD_LOOP_BIDI);
+		}
+	}
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: OpenStream
+//
+// Creates a streaming sound from a file on disk.
+//
+//==========================================================================
+
+SoundStream *FMODSoundRenderer::OpenStream(const char *filename_or_data, int flags, int offset, int length)
+{
+	FMOD_MODE mode;
+	FMOD_CREATESOUNDEXINFO exinfo;
+	FMOD::Sound *stream;
+	FMOD_RESULT result;
+	bool url;
+	FString patches;
+
+	InitCreateSoundExInfo(&exinfo);
+	mode =  FMOD_2D | FMOD_CREATESTREAM;
+	if (flags & SoundStream::Loop)
+	{
+		mode |= FMOD_LOOP_NORMAL;
+	}
+	if (offset == -1)
+	{
+		mode |= FMOD_OPENMEMORY;
+		offset = 0;
+	}
+	exinfo.length = length;
+	exinfo.fileoffset = offset;
+	if ((*snd_midipatchset)[0] != '\0')
+	{
+#ifdef _WIN32
+		// If the path does not contain any path separators, automatically
+		// prepend $PROGDIR to the path.
+		if (strcspn(snd_midipatchset, ":/\\") == strlen(snd_midipatchset))
+		{
+			patches << "$PROGDIR/" << snd_midipatchset;
+			patches = NicePath(patches);
+		}
+		else
+#endif
+		{
+			patches = NicePath(snd_midipatchset);
+		}
+		exinfo.dlsname = patches;
+	}
+
+	url = (offset == 0 && length == 0 && strstr(filename_or_data, "://") > filename_or_data);
+	if (url)
+	{
+		// Use a larger buffer for URLs so that it's less likely to be effected
+		// by hiccups in the data rate from the remote server.
+		Sys->setStreamBufferSize(64*1024, FMOD_TIMEUNIT_RAWBYTES);
+	}
+	result = Sys->createSound(filename_or_data, mode, &exinfo, &stream);
+	if (url)
+	{
+		// Restore standard buffer size.
+		Sys->setStreamBufferSize(16*1024, FMOD_TIMEUNIT_RAWBYTES);
+	}
+	if (result == FMOD_ERR_FORMAT && exinfo.dlsname != NULL)
+	{
+		// FMOD_ERR_FORMAT could refer to either the main sound file or
+		// to the DLS instrument set. Try again without special DLS
+		// instruments to see if that lets it succeed.
+		exinfo.dlsname = NULL;
+		result = Sys->createSound(filename_or_data, mode, &exinfo, &stream);
+		if (result == FMOD_OK)
+		{
+			Printf("%s is an unsupported format.\n", *snd_midipatchset);
+		}
+	}
+	if (result == FMOD_OK)
+	{
+		SetCustomLoopPts(stream);
+		return new FMODStreamCapsule(stream, this, url ? filename_or_data : NULL);
+	}
+	return NULL;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: StartSound
+//
+//==========================================================================
+
+FISoundChannel *FMODSoundRenderer::StartSound(SoundHandle sfx, float vol, int pitch, int flags, FISoundChannel *reuse_chan)
+{
+	FMOD_RESULT result;
+	FMOD_MODE mode;
+	FMOD::Channel *chan;
+	float freq;
+
+	if (FMOD_OK == ((FMOD::Sound *)sfx.data)->getDefaults(&freq, NULL))
+	{
+		freq = PITCH(freq, pitch);
+	}
+	else
+	{
+		freq = 0;
+	}
+
+	GRolloff = NULL;	// Do 2D sounds need rolloff?
+	result = Sys->playSound( (FMOD::Sound *)sfx.data,SfxGroup, true, &chan);
+	if (FMOD_OK == result)
+	{
+		result = chan->getMode(&mode);
+
+		if (result != FMOD_OK)
+		{
+			assert(0);
+		}
+		mode = (mode & ~FMOD_3D) | FMOD_2D;
+		if (flags & SNDF_LOOP)
+		{
+			mode &= ~FMOD_LOOP_OFF;
+			if (!(mode & (FMOD_LOOP_NORMAL | FMOD_LOOP_BIDI)))
+			{
+				mode |= FMOD_LOOP_NORMAL;
+			}
+		}
+		else
+		{
+			mode |= FMOD_LOOP_OFF;
+		}
+		chan->setMode(mode);
+		chan->setChannelGroup((flags & SNDF_NOPAUSE) ? SfxGroup : PausableSfx);
+		if (freq != 0)
+		{
+			chan->setFrequency(freq);
+		}
+		chan->setVolume(vol);
+		if (!HandleChannelDelay(chan, reuse_chan, flags & (SNDF_ABSTIME | SNDF_LOOP), freq))
+		{
+			chan->stop();
+			return NULL;
+		}
+		if (flags & SNDF_NOREVERB)
+		{
+			chan->setReverbProperties(0,-10000);
+		}
+		chan->setPaused(false);
+		return CommonChannelSetup(chan, reuse_chan);
+	}
+
+	//DPrintf ("Sound %s failed to play: %d\n", sfx->name.GetChars(), result);
+	return NULL;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: StartSound3D
+//
+//==========================================================================
+
+FISoundChannel *FMODSoundRenderer::StartSound3D(SoundHandle sfx, SoundListener *listener, float vol, 
+		FRolloffInfo *rolloff, float distscale,
+		int pitch, int priority, const FVector3 &pos, const FVector3 &vel,
+		int channum, int flags, FISoundChannel *reuse_chan)
+{
+	FMOD_RESULT result;
+	FMOD_MODE mode;
+	FMOD::Channel *chan;
+	float freq;
+	float def_freq, def_vol, def_pan;
+	int numchans;
+	int def_priority;
+
+	if (FMOD_OK == ((FMOD::Sound *)sfx.data)->getDefaults(&def_freq, &def_priority))
+	{
+		freq = PITCH(def_freq, pitch);
+		// Change the sound's default priority before playing it.
+		((FMOD::Sound *)sfx.data)->setDefaults(def_freq, clamp(def_priority - priority, 1, 256));
+	}
+	else
+	{
+		freq = 0;
+		def_priority = -1;
+	}
+
+	// Play it.
+	GRolloff = rolloff;
+	GDistScale = distscale;
+
+	// Experiments indicate that playSound will ignore priorities and always succeed
+	// as long as the parameters are set properly. It will first try to kick out sounds
+	// with the same priority level but has no problem with kicking out sounds at
+	// higher priority levels if it needs to.
+	result = Sys->playSound((FMOD::Sound *)sfx.data, SfxGroup, true, &chan);
+
+	// Then set the priority back.
+	if (def_priority >= 0)
+	{
+		((FMOD::Sound *)sfx.data)->setDefaults(def_freq,  def_priority);
+	}
+
+	if (FMOD_OK == result)
+	{
+		result = chan->getMode(&mode);
+		if (result != FMOD_OK)
+		{
+			mode = FMOD_3D;
+		}
+		if (flags & SNDF_LOOP)
+		{
+			mode &= ~FMOD_LOOP_OFF;
+			if (!(mode & (FMOD_LOOP_NORMAL | FMOD_LOOP_BIDI)))
+			{
+				mode |= FMOD_LOOP_NORMAL;
+			}
+		}
+		else
+		{
+			// FMOD_LOOP_OFF overrides FMOD_LOOP_NORMAL and FMOD_LOOP_BIDI
+			mode |= FMOD_LOOP_OFF;
+		}
+		mode = SetChanHeadSettings(listener, chan, pos, !!(flags & SNDF_AREA), mode);
+		chan->setMode(mode);
+		chan->setChannelGroup((flags & SNDF_NOPAUSE) ? SfxGroup : PausableSfx);
+
+		if (mode & FMOD_3D)
+		{
+			// Reduce volume of stereo sounds, because each channel will be summed together
+			// and is likely to be very similar, resulting in an amplitude twice what it
+			// would have been had it been mixed to mono.
+			if (FMOD_OK == ((FMOD::Sound *)sfx.data)->getFormat(NULL, NULL, &numchans, NULL))
+			{
+				if (numchans > 1)
+				{
+					vol *= 0.5f;
+				}
+			}
+		}
+		if (freq != 0)
+		{
+			chan->setFrequency(freq);
+		}
+		chan->setVolume(vol);
+		if (mode & FMOD_3D)
+		{
+			chan->set3DAttributes((FMOD_VECTOR *)&pos[0], (FMOD_VECTOR *)&vel[0]);
+		}
+		if (!HandleChannelDelay(chan, reuse_chan, flags & (SNDF_ABSTIME | SNDF_LOOP), freq))
+		{
+			// FMOD seems to get confused if you stop a channel right after
+			// starting it, so hopefully this function will never fail.
+			// (Presumably you need an update between them, but I haven't
+			// tested this hypothesis.)
+			chan->stop();
+			return NULL;
+		}
+		if (flags & SNDF_NOREVERB)
+		{
+			chan->setReverbProperties(0,-10000);
+		}
+		chan->setPaused(false);
+		chan->getPriority(&def_priority);
+		FISoundChannel *schan = CommonChannelSetup(chan, reuse_chan);
+		schan->Rolloff = *rolloff;
+		return schan;
+	}
+
+	GRolloff = NULL;
+	//DPrintf ("Sound %s failed to play: %d\n", sfx->name.GetChars(), result);
+	return 0;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: MarkStartTime
+//
+// Marks a channel's start time without actually playing it.
+//
+//==========================================================================
+
+void FMODSoundRenderer::MarkStartTime(FISoundChannel *chan)
+{
+	unsigned long long int dsp_time;
+	((FMOD::Channel *)chan->SysChannel)->getDSPClock(&dsp_time,NULL);
+	chan->StartTime.Lo = dsp_time & 0xFFFFFFFF; 	chan->StartTime.Hi  = dsp_time >> 32;
+	//Sys->getDSPClock(&chan->StartTime.Hi, &chan->StartTime.Lo);
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: HandleChannelDelay
+//
+// If the sound is restarting, seek it to its proper place. Returns false
+// if the sound would have ended.
+//
+// Otherwise, record its starting time, and return true.
+//
+//==========================================================================
+
+bool FMODSoundRenderer::HandleChannelDelay(FMOD::Channel *chan, FISoundChannel *reuse_chan, int flags, float freq) const
+{
+	if (reuse_chan != NULL)
+	{ // Sound is being restarted, so seek it to the position
+		// it would be in now if it had never been evicted.
+		QWORD_UNION nowtime;
+		unsigned long long int delay;
+		chan->getDelay(&delay,NULL,NULL);
+		nowtime.Lo = delay & 0xFFFFFFFF;
+		nowtime.Hi = delay >> 32;
+
+		// If abstime is set, the sound is being restored, and
+		// the channel's start time is actually its seek position.
+		if (flags & SNDF_ABSTIME)
+		{
+			unsigned int seekpos = reuse_chan->StartTime.Lo;
+			if (seekpos > 0)
+			{
+				chan->setPosition(seekpos, FMOD_TIMEUNIT_PCM);
+			}
+			reuse_chan->StartTime.AsOne = QWORD(nowtime.AsOne - seekpos * OutputRate / freq);
+		}
+		else if (reuse_chan->StartTime.AsOne != 0)
+		{
+			QWORD difftime = nowtime.AsOne - reuse_chan->StartTime.AsOne;
+			if (difftime > 0)
+			{
+				// Clamp the position of looping sounds to be within the sound.
+				// If we try to start it several minutes past its normal end,
+				// FMOD doesn't like that.
+				// FIXME: Clamp this right for loops that don't cover the whole sound.
+				if (flags & SNDF_LOOP)
+				{
+					FMOD::Sound *sound;
+					if (FMOD_OK == chan->getCurrentSound(&sound))
+					{
+						unsigned int len;
+						if (FMOD_OK == sound->getLength(&len, FMOD_TIMEUNIT_MS) && len != 0)
+						{
+							difftime %= len;
+						}
+					}
+				}
+				return chan->setPosition((unsigned int)(difftime / OutputRate), FMOD_TIMEUNIT_MS) == FMOD_OK;
+			}
+		}
+	}
+	else
+	{
+		//		chan->setDelay(FMOD_DELAYTYPE_DSPCLOCK_START, DSPClock.Hi, DSPClock.Lo);
+	}
+	return true;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: SetChanHeadSettings
+//
+// If this sound is played at the same coordinates as the listener, make
+// it head relative. Also, area sounds should use no 3D panning if close
+// enough to the listener.
+//
+//==========================================================================
+
+FMOD_MODE FMODSoundRenderer::SetChanHeadSettings(SoundListener *listener, FMOD::Channel *chan,
+		const FVector3 &pos, bool areasound,
+		FMOD_MODE oldmode) const
+{
+	if (!listener->valid)
+	{
+		return oldmode;
+	}
+	FVector3 cpos, mpos;
+
+	cpos = listener->position;
+
+	if (areasound)
+	{
+		float level, old_level;
+
+		// How far are we from the perceived sound origin? Within a certain
+		// short distance, we interpolate between 2D panning and full 3D panning.
+		const double interp_range = 32.0;
+		double dist_sqr = (cpos - pos).LengthSquared();
+
+		if (dist_sqr == 0)
+		{
+			level = 0;
+		}
+		else if (dist_sqr <= interp_range * interp_range)
+		{ // Within interp_range: Interpolate between none and full 3D panning.
+			level = float(1 - (interp_range - sqrt(dist_sqr)) / interp_range);
+		}
+		else
+		{ // Beyond interp_range: Normal 3D panning.
+			level = 1;
+		}
+		if (chan->get3DLevel(&old_level) == FMOD_OK && old_level != level)
+		{ // Only set it if it's different.
+			chan->set3DLevel(level);
+			if (level < 1)
+			{ // Let the noise come from all speakers, not just the front ones.
+				// A centered 3D sound does not play at full volume, so neither should the 2D-panned one.
+				// This is sqrt(0.5), which is the result for a centered equal power panning.
+				chan->setMixLevelsOutput(0.70711f,0.70711f,0.70711f,0.70711f,0.70711f,0.70711f,0.70711f,0.70711f);
+			}
+		}
+		return oldmode;
+	}
+	else if (cpos == pos)
+	{ // Head relative
+		return (oldmode & ~FMOD_3D) | FMOD_2D;
+	}
+	// World relative
+	return (oldmode & ~FMOD_2D) | FMOD_3D;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: CommonChannelSetup
+//
+// Assign an end callback to the channel and allocates a game channel for
+// it.
+//
+//==========================================================================
+
+FISoundChannel *FMODSoundRenderer::CommonChannelSetup(FMOD::Channel *chan, FISoundChannel *reuse_chan) const
+{
+	FISoundChannel *schan;
+
+	if (reuse_chan != NULL)
+	{
+		schan = reuse_chan;
+		schan->SysChannel = chan;
+	}
+	else
+	{
+		schan = S_GetChannel(chan);
+		unsigned long long int time;
+		chan->getDelay(&time,NULL,NULL);
+
+		schan->StartTime.Lo = time & 0xFFFFFFFF ; schan->StartTime.Hi = time >> 32;
+	}
+	chan->setUserData(schan);
+	chan->setCallback(ChannelCallback);
+	GRolloff = NULL;
+	return schan;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: StopSound
+//
+//==========================================================================
+
+void FMODSoundRenderer::StopChannel(FISoundChannel *chan)
+{
+	if (chan != NULL && chan->SysChannel != NULL)
+	{
+		((FMOD::Channel *)chan->SysChannel)->stop();
+	}
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: ChannelVolume
+//
+//==========================================================================
+
+void FMODSoundRenderer::ChannelVolume(FISoundChannel *chan, float volume)
+{
+	if (chan != NULL && chan->SysChannel != NULL)
+	{
+		((FMOD::Channel *)chan->SysChannel)->setVolume(volume);
+	}
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: GetPosition
+//
+// Returns position of sound on this channel, in samples.
+//
+//==========================================================================
+
+unsigned int FMODSoundRenderer::GetPosition(FISoundChannel *chan)
+{
+	unsigned int pos;
+
+	if (chan == NULL || chan->SysChannel == NULL)
+	{
+		return 0;
+	}
+	((FMOD::Channel *)chan->SysChannel)->getPosition(&pos, FMOD_TIMEUNIT_PCM);
+	return pos;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: GetAudibility
+//
+// Returns the audible volume of the channel, after rollof and any other
+// factors are applied.
+//
+//==========================================================================
+
+float FMODSoundRenderer::GetAudibility(FISoundChannel *chan)
+{
+	float aud;
+
+	if (chan == NULL || chan->SysChannel == NULL)
+	{
+		return 0;
+	}
+	((FMOD::Channel *)chan->SysChannel)->getAudibility(&aud);
+	return aud;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: SetSfxPaused
+//
+//==========================================================================
+
+void FMODSoundRenderer::SetSfxPaused(bool paused, int slot)
+{
+	int oldslots = SFXPaused;
+
+	if (paused)
+	{
+		SFXPaused |= 1 << slot;
+	}
+	else
+	{
+		SFXPaused &= ~(1 << slot);
+	}
+	//Printf("%d\n", SFXPaused);
+	if (oldslots != 0 && SFXPaused == 0)
+	{
+		PausableSfx->setPaused(false);
+	}
+	else if (oldslots == 0 && SFXPaused != 0)
+	{
+		PausableSfx->setPaused(true);
+	}
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: SetInactive
+//
+// This is similar to SetSfxPaused but will *pause* everything, including
+// the global reverb effect. This is meant to be used only when the
+// game is deactivated, not for general sound pausing.
+//
+//==========================================================================
+
+void FMODSoundRenderer::SetInactive(SoundRenderer::EInactiveState inactive)
+{
+	float mix;
+	bool active;
+
+	if (inactive == INACTIVE_Active)
+	{
+		mix = 1;
+		active = true;
+	}
+	else if (inactive == INACTIVE_Complete)
+	{
+		mix = 1;
+		active = false;
+	}
+	else // inactive == INACTIVE_Mute
+	{
+		mix = 0;
+		active = true;
+	}
+	if (ChannelGroupTargetUnitOutput != NULL)
+	{
+		ChannelGroupTargetUnitOutput->setMix(mix);
+	}
+	if (ChannelGroupTargetUnit != NULL)
+	{
+		ChannelGroupTargetUnit->setActive(active);
+	}
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: UpdateSoundParams3D
+//
+//==========================================================================
+
+void FMODSoundRenderer::UpdateSoundParams3D(SoundListener *listener, FISoundChannel *chan, bool areasound, const FVector3 &pos, const FVector3 &vel)
+{
+	if (chan == NULL || chan->SysChannel == NULL)
+		return;
+
+	FMOD::Channel *fchan = (FMOD::Channel *)chan->SysChannel;
+	FMOD_MODE oldmode, mode;
+
+	if (fchan->getMode(&oldmode) != FMOD_OK)
+	{
+		oldmode = FMOD_3D;
+	}
+	mode = SetChanHeadSettings(listener, fchan, pos, areasound, oldmode);
+	if (mode != oldmode)
+	{ // Only set the mode if it changed.
+		fchan->setMode(mode);
+	}
+	fchan->set3DAttributes((FMOD_VECTOR *)&pos[0], (FMOD_VECTOR *)&vel[0]);
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: UpdateListener
+//
+//==========================================================================
+
+void FMODSoundRenderer::UpdateListener(SoundListener *listener)
+{
+	FMOD_VECTOR pos, vel;
+	FMOD_VECTOR forward;
+	FMOD_VECTOR up;
+
+	if (!listener->valid)
+	{
+		return;
+	}
+
+	// Set velocity to 0 to prevent crazy doppler shifts just from running.
+
+	vel.x = listener->velocity.X;
+	vel.y = listener->velocity.Y;
+	vel.z = listener->velocity.Z;
+	pos.x = listener->position.X;
+	pos.y = listener->position.Y;
+	pos.z = listener->position.Z;
+
+	float angle = listener->angle;
+	forward.x = cos(angle);
+	forward.y = 0;
+	forward.z = sin(angle);
+
+	up.x = 0;
+	up.y = 1;
+	up.z = 0;
+
+	Sys->set3DListenerAttributes(0, &pos, &vel, &forward, &up);
+
+	bool underwater = false;
+	const ReverbContainer *env;
+
+	underwater = (listener->underwater && snd_waterlp);
+	if (ForcedEnvironment)
+	{
+		env = ForcedEnvironment;
+	}
+	else
+	{
+		env = listener->Environment;
+		if (env == NULL)
+		{
+			env = DefaultEnvironments[0];
+		}
+	}
+	if (env != PrevEnvironment || env->Modified)
+	{
+		DPrintf ("Reverb Environment %s\n", env->Name);
+		const_cast<ReverbContainer*>(env)->Modified = false;
+		SetSystemReverbProperties(&env->Properties);
+		PrevEnvironment = env;
+
+		if (!SfxReverbHooked)
+		{
+			SfxReverbHooked = ReconnectSFXReverbUnit();
+		}
+	}
+
+	if (underwater || env->SoftwareWater)
+	{
+		//PausableSfx->setPitch(0.64171f);		// This appears to be what Duke 3D uses
+		PausableSfx->setPitch(0.7937005f);		// Approx. 4 semitones lower; what Nash suggested
+		if (WaterLP != NULL)
+		{
+			if (LastWaterLP != snd_waterlp)
+			{
+				LastWaterLP = snd_waterlp;
+				WaterLP->setParameterFloat(FMOD_DSP_LOWPASS_CUTOFF, snd_waterlp);
+			}
+			WaterLP->setActive(true);
+			if (WaterReverb != NULL && snd_waterreverb)
+			{
+				WaterReverb->setActive(true);
+				WaterReverb->setBypass(false);
+				SfxConnection->setMix(0);
+			}
+			else
+			{
+				// Let some of the original mix through so that high frequencies are
+				// not completely lost. The reverb unit has its own connection and
+				// preserves dry sounds itself if used.
+				SfxConnection->setMix(0.1f);
+				if (WaterReverb != NULL)
+				{
+					WaterReverb->setActive(true);
+					WaterReverb->setBypass(true);
+				}
+			}
+		}
+	}
+	else
+	{
+		PausableSfx->setPitch(1);
+		if (WaterLP != NULL)
+		{
+			SfxConnection->setMix(1);
+			WaterLP->setActive(false);
+			if (WaterReverb != NULL)
+			{
+				WaterReverb->setActive(false);
+			}
+		}
+	}
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: ReconnectSFXReverbUnit
+//
+// Locates the DSP unit responsible for software 3D reverb. There is only
+// one, and it by default is connected directly to the ChannelGroup Target
+// Unit. Older versions of FMOD created this at startup; newer versions
+// delay creating it until the first call to setReverbProperties, at which
+// point it persists until the system is closed.
+//
+// Upon locating the proper DSP unit, reconnects it to serve as an input to
+// our water DSP chain after the Pausable SFX ChannelGroup.
+//
+//==========================================================================
+
+bool FMODSoundRenderer::ReconnectSFXReverbUnit()
+{
+	FMOD::DSP *unit;
+	FMOD_DSP_TYPE type;
+	int numinputs, i;
+
+	if (ChannelGroupTargetUnit == NULL || SfxReverbPlaceholder == NULL)
+	{
+		return false;
+	}
+	// Look for SFX Reverb unit
+	if (FMOD_OK != ChannelGroupTargetUnit->getNumInputs(&numinputs))
+	{
+		return false;
+	}
+	for (i = numinputs - 1; i >= 0; --i)
+	{
+		if (FMOD_OK == ChannelGroupTargetUnit->getInput(i, &unit, NULL) &&
+				FMOD_OK == unit->getType(&type))
+		{
+			if (type == FMOD_DSP_TYPE_SFXREVERB)
+			{
+				break;
+			}
+		}
+	}
+	if (i < 0)
+	{
+		return false;
+	}
+
+	// Found it! Now move it in the DSP graph to be done before the water
+	// effect.
+	if (FMOD_OK != ChannelGroupTargetUnit->disconnectFrom(unit))
+	{
+		return false;
+	}
+	if (FMOD_OK != SfxReverbPlaceholder->addInput(unit, NULL))
+	{
+		return false;
+	}
+	return true;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: Sync
+//
+// Used by the save/load code to restart sounds at the same position they
+// were in at the time of saving. Must not be nested.
+//
+//==========================================================================
+
+void FMODSoundRenderer::Sync(bool sync)
+{
+	DSPLocked = sync;
+	if (sync)
+	{
+		Sys->lockDSP();
+		//Sys->getDSPClock(&DSPClock.Hi, &DSPClock.Lo);
+	}
+	else
+	{
+		Sys->unlockDSP();
+	}
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: UpdateSounds
+//
+//==========================================================================
+
+void FMODSoundRenderer::UpdateSounds()
+{
+	// Any sounds played between now and the next call to this function
+	// will start exactly one tic from now.
+
+
+	//Sys->getDSPClock(&DSPClock.Hi, &DSPClock.Lo);
+	//DSPClock.AsOne += OutputRate / TICRATE;
+
+	//TODO check this...
+	unsigned long long int clock;
+	SfxGroup->getDSPClock(&clock,NULL);
+	DSPClock.Lo = clock & 0xFFFFFFFF;
+	DSPClock.Hi = clock >> 32;
+	DSPClock.AsOne += OutputRate / TICRATE;
+
+	Sys->update();
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: LoadSoundRaw
+//
+//==========================================================================
+
+SoundHandle FMODSoundRenderer::LoadSoundRaw(BYTE *sfxdata, int length, int frequency, int channels, int bits, int loopstart, int loopend)
+{
+	FMOD_CREATESOUNDEXINFO exinfo;
+	SoundHandle retval = { NULL };
+	int numsamples;
+
+	if (length <= 0)
+	{
+		return retval;
+	}
+
+	InitCreateSoundExInfo(&exinfo);
+	exinfo.length = length;
+	exinfo.numchannels = channels;
+	exinfo.defaultfrequency = frequency;
+	switch (bits)
+	{
+	case 8:
+		// Need to convert sample data from unsigned to signed.
+		for (int i = 0; i < length; ++i)
+		{
+			sfxdata[i] = sfxdata[i] - 128;
+		}
+
+	case -8:
+		exinfo.format = FMOD_SOUND_FORMAT_PCM8;
+		numsamples = length;
+		break;
+
+	case 16:
+		exinfo.format = FMOD_SOUND_FORMAT_PCM16;
+		numsamples = length >> 1;
+		break;
+
+	case 32:
+		exinfo.format = FMOD_SOUND_FORMAT_PCM32;
+		numsamples = length >> 2;
+		break;
+
+	default:
+		return retval;
+	}
+
+	const FMOD_MODE samplemode = FMOD_3D | FMOD_OPENMEMORY | FMOD_OPENRAW;
+	FMOD::Sound *sample;
+	FMOD_RESULT result;
+
+	result = Sys->createSound((char *)sfxdata, samplemode, &exinfo, &sample);
+	if (result != FMOD_OK)
+	{
+		DPrintf("Failed to allocate sample: Error %d\n", result);
+		return retval;
+	}
+
+	if (loopstart >= 0)
+	{
+		if (loopend == -1)
+			loopend = numsamples - 1;
+		sample->setLoopPoints(loopstart, FMOD_TIMEUNIT_PCM, loopend, FMOD_TIMEUNIT_PCM);
+	}
+
+	retval.data = sample;
+	return retval;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: LoadSound
+//
+//==========================================================================
+
+SoundHandle FMODSoundRenderer::LoadSound(BYTE *sfxdata, int length)
+{
+	FMOD_CREATESOUNDEXINFO exinfo;
+	SoundHandle retval = { NULL };
+
+	if (length == 0) return retval;
+
+	InitCreateSoundExInfo(&exinfo);
+	exinfo.length = length;
+
+	const FMOD_MODE samplemode = FMOD_3D | FMOD_OPENMEMORY;
+	FMOD::Sound *sample;
+	FMOD_RESULT result;
+
+	result = Sys->createSound((char *)sfxdata, samplemode, &exinfo, &sample);
+	if (result != FMOD_OK)
+	{
+		DPrintf("Failed to allocate sample: Error %d\n", result);
+		return retval;
+	}
+	SetCustomLoopPts(sample);
+	retval.data = sample;
+	return retval;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: UnloadSound
+//
+//==========================================================================
+
+void FMODSoundRenderer::UnloadSound(SoundHandle sfx)
+{
+	if (sfx.data != NULL)
+	{
+		((FMOD::Sound *)sfx.data)->release();
+	}
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: GetMSLength
+//
+//==========================================================================
+
+unsigned int FMODSoundRenderer::GetMSLength(SoundHandle sfx)
+{
+	if (sfx.data != NULL)
+	{
+		unsigned int length;
+
+		if (((FMOD::Sound *)sfx.data)->getLength(&length, FMOD_TIMEUNIT_MS) == FMOD_OK)
+		{
+			return length;
+		}
+	}
+	return 0;	// Don't know.
+}
+
+
+//==========================================================================
+//
+// FMODSoundRenderer :: GetMSLength
+//
+//==========================================================================
+
+unsigned int FMODSoundRenderer::GetSampleLength(SoundHandle sfx)
+{
+	if (sfx.data != NULL)
+	{
+		unsigned int length;
+
+		if (((FMOD::Sound *)sfx.data)->getLength(&length, FMOD_TIMEUNIT_PCM) == FMOD_OK)
+		{
+			return length;
+		}
+	}
+	return 0;	// Don't know.
+}
+
+
+//==========================================================================
+//
+// FMODSoundRenderer :: ChannelCallback								static
+//
+// Handles when a channel finishes playing. This is only called when
+// System::update is called and is therefore asynchronous with the actual
+// end of the channel.
+//
+//==========================================================================
+
+FMOD_RESULT F_CALLBACK FMODSoundRenderer::ChannelCallback
+(FMOD_CHANNELCONTROL *channel, FMOD_CHANNELCONTROL_TYPE controltype, FMOD_CHANNELCONTROL_CALLBACK_TYPE callbacktype,
+		void *data1, void *data2)
+{
+	FMOD::Channel *chan = (FMOD::Channel *)channel;
+	FISoundChannel *schan;
+
+	if (chan->getUserData((void **)&schan) == FMOD_OK && schan != NULL)
+	{
+		if (callbacktype == FMOD_CHANNELCONTROL_CALLBACK_END)
+		{
+			S_ChannelEnded(schan);
+		}
+		else if (callbacktype == FMOD_CHANNELCONTROL_CALLBACK_VIRTUALVOICE)
+		{
+			S_ChannelVirtualChanged(schan, data1 != 0);
+		}
+	}
+	return FMOD_OK;
+}
+
+
+//==========================================================================
+//
+// FMODSoundRenderer :: RolloffCallback								static
+//
+// Calculates a volume for the sound based on distance.
+//
+//==========================================================================
+
+float F_CALLBACK FMODSoundRenderer::RolloffCallback(FMOD_CHANNELCONTROL *channel, float distance)
+{
+	FMOD::Channel *chan = (FMOD::Channel *)channel;
+	FISoundChannel *schan;
+
+	if (GRolloff != NULL)
+	{
+		return S_GetRolloff(GRolloff, distance * GDistScale, true);
+	}
+	else if (chan->getUserData((void **)&schan) == FMOD_OK && schan != NULL)
+	{
+		return S_GetRolloff(&schan->Rolloff, distance * schan->DistanceScale, true);
+	}
+	else
+	{
+		return 0;
+	}
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: DrawWaveDebug
+//
+// Bit 0: ( 1) Show oscilloscope for sfx.
+// Bit 1: ( 2) Show spectrum for sfx.
+// Bit 2: ( 4) Show oscilloscope for music.
+// Bit 3: ( 8) Show spectrum for music.
+// Bit 4: (16) Show oscilloscope for all sounds.
+// Bit 5: (32) Show spectrum for all sounds.
+//
+//==========================================================================
+
+void FMODSoundRenderer::DrawWaveDebug(int mode)
+{
+	const int window_height = 100;
+	int window_size;
+	int numoutchans;
+	int y, yy;
+	const spk *labels;
+	int labelcount;
+
+	if (FMOD_OK != Sys->getSoftwareFormat(NULL, NULL, &numoutchans))
+	{
+		return;
+	}
+
+	// Decide on which set of labels to use.
+	labels = (numoutchans == 4) ? SpeakerNames4 : SpeakerNamesMore;
+	labelcount = MIN<int>(numoutchans, countof(SpeakerNamesMore));
+
+	// Scale all the channel windows so one group fits completely on one row, with
+	// 16 pixels of padding between each window.
+	window_size = (screen->GetWidth() - 16) / numoutchans - 16;
+
+	float *wavearray = (float*)alloca(MAX(SPECTRUM_SIZE,window_size)*sizeof(float));
+	y = 16;
+
+	yy = DrawChannelGroupOutput(SfxGroup, wavearray, window_size, window_height, y, mode);
+	if (y != yy)
+	{
+		DrawSpeakerLabels(labels, yy-14, window_size, labelcount);
+	}
+	y = DrawChannelGroupOutput(MusicGroup, wavearray, window_size, window_height, yy, mode >> 2);
+	if (y != yy)
+	{
+		DrawSpeakerLabels(labels, y-14, window_size, labelcount);
+	}
+	yy = DrawSystemOutput(wavearray, window_size, window_height, y, mode >> 4);
+	if (y != yy)
+	{
+		DrawSpeakerLabels(labels, yy-14, window_size, labelcount);
+	}
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: DrawSpeakerLabels
+//
+//==========================================================================
+
+void FMODSoundRenderer::DrawSpeakerLabels(const spk *labels, int y, int width, int count)
+{
+	if (labels == NULL)
+	{
+		return;
+	}
+	for (int i = 0, x = 16; i < count; ++i)
+	{
+		screen->DrawText(SmallFont, CR_LIGHTBLUE, x, y, labels[i], TAG_DONE);
+		x += width + 16;
+	}
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: DrawChannelGroupOutput
+//
+// Draws an oscilloscope and/or a spectrum for a channel group.
+//
+//==========================================================================
+
+int FMODSoundRenderer::DrawChannelGroupOutput(FMOD::ChannelGroup *group, float *wavearray, int width, int height, int y, int mode)
+{
+	int y1, y2;
+
+	switch (mode & 0x03)
+	{
+	case 0x01:		// Oscilloscope only
+		return DrawChannelGroupWaveData(group, wavearray, width, height, y, false);
+
+	case 0x02:		// Spectrum only
+		return DrawChannelGroupSpectrum(group, wavearray, width, height, y, false);
+
+	case 0x03:		// Oscilloscope + Spectrum
+		width = (width + 16) / 2 - 16;
+		y1 = DrawChannelGroupSpectrum(group, wavearray, width, height, y, true);
+		y2 = DrawChannelGroupWaveData(group, wavearray, width, height, y, true);
+		return MAX(y1, y2);
+	}
+	return y;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: DrawSystemOutput
+//
+// Like DrawChannelGroupOutput(), but uses the system object.
+//
+//==========================================================================
+
+int FMODSoundRenderer::DrawSystemOutput(float *wavearray, int width, int height, int y, int mode)
+{
+	int y1, y2;
+
+	switch (mode & 0x03)
+	{
+	case 0x01:		// Oscilloscope only
+		return DrawSystemWaveData(wavearray, width, height, y, false);
+
+	case 0x02:		// Spectrum only
+		return DrawSystemSpectrum(wavearray, width, height, y, false);
+
+	case 0x03:		// Oscilloscope + Spectrum
+		width = (width + 16) / 2 - 16;
+		y1 = DrawSystemSpectrum(wavearray, width, height, y, true);
+		y2 = DrawSystemWaveData(wavearray, width, height, y, true);
+		return MAX(y1, y2);
+	}
+	return y;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: DrawChannelGroupWaveData
+//
+// Draws all the output channels for a specified channel group.
+// Setting skip to true causes it to skip every other window.
+//
+//==========================================================================
+
+int FMODSoundRenderer::DrawChannelGroupWaveData(FMOD::ChannelGroup *group, float *wavearray, int width, int height, int y, bool skip)
+{
+	/* TODO fix this
+	int drawn = 0;
+	int x = 16;
+
+	while (FMOD_OK == group->getWaveData(wavearray, width, drawn))
+	{
+		drawn++;
+		DrawWave(wavearray, x, y, width, height);
+		x += (width + 16) << int(skip);
+	}
+	if (drawn)
+	{
+		y += height + 16;
+	}
+	 */
+	return y;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer::DrawSystemWaveData
+//
+// Like DrawChannelGroupWaveData, but it uses the system object to get the
+// complete output.
+//
+//==========================================================================
+
+int FMODSoundRenderer::DrawSystemWaveData(float *wavearray, int width, int height, int y, bool skip)
+{
+	/*
+	int drawn = 0;
+	int x = 16;
+
+	while (FMOD_OK == Sys->getWaveData(wavearray, width, drawn))
+	{
+		drawn++;
+		DrawWave(wavearray, x, y, width, height);
+		x += (width + 16) << int(skip);
+	}
+	if (drawn)
+	{
+		y += height + 16;
+	}
+	 */
+	return y;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: DrawWave
+//
+// Draws an oscilloscope at the specified coordinates on the screen. Each
+// entry in the wavearray buffer has its own column. IOW, there are <width>
+// entries in wavearray.
+//
+//==========================================================================
+
+void FMODSoundRenderer::DrawWave(float *wavearray, int x, int y, int width, int height)
+{
+	float scale = height / 2.f;
+	float mid = y + scale;
+	int i;
+
+	// Draw a box around the oscilloscope.
+	screen->DrawLine(x - 1, y - 1, x + width, y - 1, -1, MAKEARGB(160, 0, 40, 200));
+	screen->DrawLine(x + width, y - 1, x + width, y + height, -1, MAKEARGB(160, 0, 40, 200));
+	screen->DrawLine(x + width, y + height, x - 1, y + height, -1, MAKEARGB(160, 0, 40, 200));
+	screen->DrawLine(x - 1, y + height, x - 1, y - 1, -1, MAKEARGB(160, 0, 40, 200));
+
+	// Draw the actual oscilloscope.
+	if (screen->Accel2D)
+	{ // Drawing this with lines is super-slow without hardware acceleration, at least with
+		// the debug build.
+		float lasty = mid - wavearray[0] * scale;
+		float newy;
+		for (i = 1; i < width; ++i)
+		{
+			newy = mid - wavearray[i] * scale;
+			screen->DrawLine(x + i - 1, int(lasty), x + i, int(newy), -1, MAKEARGB(255,255,248,248));
+			lasty = newy;
+		}
+	}
+	else
+	{
+		for (i = 0; i < width; ++i)
+		{
+			float y = wavearray[i] * scale + mid;
+			screen->DrawPixel(x + i, int(y), -1, MAKEARGB(255,255,255,255));
+		}
+	}
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: DrawChannelGroupSpectrum
+//
+// Draws all the spectrum for a specified channel group.
+// Setting skip to true causes it to skip every other window, starting at
+// the second one.
+//
+//==========================================================================
+
+int FMODSoundRenderer::DrawChannelGroupSpectrum(FMOD::ChannelGroup *group, float *spectrumarray, int width, int height, int y, bool skip)
+{
+	/*
+	int drawn = 0;
+	int x = 16;
+
+	if (skip)
+	{
+		x += width + 16;
+	}
+	while (FMOD_OK == group->getSpectrum(spectrumarray, SPECTRUM_SIZE, drawn, FMOD_DSP_FFT_WINDOW_TRIANGLE))
+	{
+		drawn++;
+		DrawSpectrum(spectrumarray, x, y, width, height);
+		x += (width + 16) << int(skip);
+	}
+	if (drawn)
+	{
+		y += height + 16;
+	}
+	 */
+	return y;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer::DrawSystemSpectrum
+//
+// Like DrawChannelGroupSpectrum, but it uses the system object to get the
+// complete output.
+//
+//==========================================================================
+
+int FMODSoundRenderer::DrawSystemSpectrum(float *spectrumarray, int width, int height, int y, bool skip)
+{
+	/*
+	int drawn = 0;
+	int x = 16;
+
+	if (skip)
+	{
+		x += width + 16;
+	}
+	while (FMOD_OK == Sys->getSpectrum(spectrumarray, SPECTRUM_SIZE, drawn, FMOD_DSP_FFT_WINDOW_TRIANGLE))
+	{
+		drawn++;
+		DrawSpectrum(spectrumarray, x, y, width, height);
+		x += (width + 16) << int(skip);
+	}
+	if (drawn)
+	{
+		y += height + 16;
+	}
+	 */
+	return y;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: DrawSpectrum
+//
+// Draws a spectrum at the specified coordinates on the screen.
+//
+//==========================================================================
+
+void FMODSoundRenderer::DrawSpectrum(float *spectrumarray, int x, int y, int width, int height)
+{
+	float scale = height / 2.f;
+	float mid = y + scale;
+	float db;
+	int top;
+
+	// Draw a border and dark background for the spectrum.
+	screen->DrawLine(x - 1, y - 1, x + width, y - 1, -1, MAKEARGB(160, 0, 40, 200));
+	screen->DrawLine(x + width, y - 1, x + width, y + height, -1, MAKEARGB(160, 0, 40, 200));
+	screen->DrawLine(x + width, y + height, x - 1, y + height, -1, MAKEARGB(160, 0, 40, 200));
+	screen->DrawLine(x - 1, y + height, x - 1, y - 1, -1, MAKEARGB(160, 0, 40, 200));
+	screen->Dim(MAKERGB(0,0,0), 0.3f, x, y, width, height);
+
+	// Draw the actual spectrum.
+	for (int i = 0; i < width; ++i)
+	{
+		db = spectrumarray[i * (SPECTRUM_SIZE - 2) / width + 1];
+		db = MAX(-150.f, 10 * log10f(db) * 2);		// Convert to decibels and clamp
+		db = 1.f - (db / -150.f);
+		db *= height;
+		top = (int)db;
+		if (top >= height)
+		{
+			top = height - 1;
+		}
+		//		screen->Clear(x + i, int(y + height - db), x + i + 1, y + height, -1, MAKEARGB(255, 255, 255, 40));
+		screen->Dim(MAKERGB(255,255,40), 0.65f, x + i, y + height - top, 1, top);
+	}
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: DecodeSample
+//
+// Uses FMOD to decode a compressed sample to a 16-bit buffer. This is used
+// by the DUMB XM reader to handle FMOD's OggMods.
+//
+//==========================================================================
+
+short *FMODSoundRenderer::DecodeSample(int outlen, const void *coded, int sizebytes, ECodecType type)
+{
+	FMOD_CREATESOUNDEXINFO exinfo;
+	FMOD::Sound *sound;
+	FMOD_SOUND_FORMAT format;
+	int channels;
+	unsigned int len, amt_read;
+	FMOD_RESULT result;
+	short *outbuf;
+
+	InitCreateSoundExInfo(&exinfo);
+	if (type == CODEC_Vorbis)
+	{
+		exinfo.suggestedsoundtype = FMOD_SOUND_TYPE_OGGVORBIS;
+	}
+	exinfo.length = sizebytes;
+	result = Sys->createSound((const char *)coded,
+			FMOD_2D  | FMOD_CREATESTREAM |
+			FMOD_OPENMEMORY_POINT | FMOD_OPENONLY | FMOD_LOWMEM,
+			&exinfo, &sound);
+	if (result != FMOD_OK)
+	{
+		return NULL;
+	}
+	result = sound->getFormat(NULL, &format, &channels, NULL);
+	// TODO: Handle more formats if it proves necessary.
+	if (result != FMOD_OK || format != FMOD_SOUND_FORMAT_PCM16 || channels != 1)
+	{
+		sound->release();
+		return NULL;
+	}
+	len = outlen;
+	// Must be malloc'ed for DUMB, which is C.
+	outbuf = (short *)malloc(len);
+	result = sound->readData(outbuf, len, &amt_read);
+	sound->release();
+	if (result == FMOD_ERR_FILE_EOF)
+	{
+		memset((BYTE *)outbuf + amt_read, 0, len - amt_read);
+	}
+	else if (result != FMOD_OK || amt_read != len)
+	{
+		free(outbuf);
+		return NULL;
+	}
+	return outbuf;
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: InitCreateSoundExInfo
+//
+// Allow for compiling with 4.26 APIs while still running with older DLLs.
+//
+//==========================================================================
+
+void FMODSoundRenderer::InitCreateSoundExInfo(FMOD_CREATESOUNDEXINFO *exinfo) const
+{
+	memset(exinfo, 0, sizeof(*exinfo));
+#if FMOD_VERSION >= 0x42600 && FMOD_VERSION < 0x43800
+	if (ActiveFMODVersion < 0x42600)
+	{
+		// This parameter was added for 4.26.00, and trying to pass it to older
+		// DLLs will fail.
+		exinfo->cbsize = myoffsetof(FMOD_CREATESOUNDEXINFO, ignoresetfilesystem);
+	}
+	else
+#endif
+	{
+		exinfo->cbsize = sizeof(*exinfo);
+	}
+}
+
+//==========================================================================
+//
+// FMODSoundRenderer :: SetSystemReverbProperties
+//
+// Set the global reverb properties.
+//
+//==========================================================================
+
+FMOD_RESULT FMODSoundRenderer::SetSystemReverbProperties(const REVERB_PROPERTIES *props)
+{
+	/* TODO fix this
+	// The reverb format changed when hardware mixing support was dropped, because
+	// all EAX-only properties were removed from the structure.
+	FMOD_REVERB_PROPERTIES fr;
+
+	fr.Instance = props->Instance;
+	fr.Environment = props->Environment;
+	fr.EnvDiffusion = props->EnvDiffusion;
+	fr.Room = props->Room;
+	fr.RoomHF = props->RoomHF;
+	fr.RoomLF = props->RoomLF;
+	fr.DecayTime = props->DecayTime;
+	fr.DecayHFRatio = props->DecayHFRatio;
+	fr.DecayLFRatio = props->DecayLFRatio;
+	fr.Reflections = props->Reflections;
+	fr.ReflectionsDelay = props->ReflectionsDelay;
+	fr.Reverb = props->Reverb;
+	fr.ReverbDelay = props->ReverbDelay;
+	fr.ModulationTime = props->ModulationTime;
+	fr.ModulationDepth = props->ModulationDepth;
+	fr.HFReference = props->HFReference;
+	fr.LFReference = props->LFReference;
+	fr.Diffusion = props->Diffusion;
+	fr.Density = props->Density;
+	fr.Flags = props->Flags;
+
+	return Sys->setReverbProperties(&fr);
+	 */
+    return FMOD_OK;
+
+}
+#endif // NO_FMOD
diff --git a/src/sound/fmodsound_studio.h b/src/sound/fmodsound_studio.h
new file mode 100755
index 0000000..5b16a24
--- /dev/null
+++ b/src/sound/fmodsound_studio.h
@@ -0,0 +1,137 @@
+#ifndef FMODSOUND_H
+#define FMODSOUND_H
+
+#include "i_sound.h"
+
+#ifndef NO_FMOD
+#include "fmod_wrap.h"
+
+#define NO_FMOD_CAPS_FIX_ME
+
+class FMODSoundRenderer : public SoundRenderer
+{
+public:
+	FMODSoundRenderer ();
+	~FMODSoundRenderer ();
+	bool IsValid ();
+
+	void SetSfxVolume (float volume);
+	void SetMusicVolume (float volume);
+	SoundHandle LoadSound(BYTE *sfxdata, int length);
+	SoundHandle LoadSoundRaw(BYTE *sfxdata, int length, int frequency, int channels, int bits, int loopstart, int loopend = -1);
+	void UnloadSound (SoundHandle sfx);
+	unsigned int GetMSLength(SoundHandle sfx);
+	unsigned int GetSampleLength(SoundHandle sfx);
+	float GetOutputRate();
+
+	// Streaming sounds.
+	SoundStream *CreateStream (SoundStreamCallback callback, int buffsamples, int flags, int samplerate, void *userdata);
+	//SoundStream *OpenStream (const char *filename, int flags, int offset, int length);
+    SoundStream *OpenStream (FileReader *reader, int flags) = 0;
+    SoundStream *OpenStream (const char *url, int flags);
+    
+	long PlayStream (SoundStream *stream, int volume);
+	void StopStream (SoundStream *stream);
+
+	// Starts a sound.
+	FISoundChannel *StartSound (SoundHandle sfx, float vol, int pitch, int chanflags, FISoundChannel *reuse_chan);
+	FISoundChannel *StartSound3D (SoundHandle sfx, SoundListener *listener, float vol, FRolloffInfo *rolloff, float distscale, int pitch, int priority, const FVector3 &pos, const FVector3 &vel, int channum, int chanflags, FISoundChannel *reuse_chan);
+
+	// Stops a sound channel.
+	void StopChannel (FISoundChannel *chan);
+
+	// Changes a channel's volume.
+	void ChannelVolume (FISoundChannel *chan, float volume);
+
+	// Marks a channel's start time without actually playing it.
+	void MarkStartTime (FISoundChannel *chan);
+
+	// Returns position of sound on this channel, in samples.
+	unsigned int GetPosition(FISoundChannel *chan);
+
+	// Gets a channel's audibility (real volume).
+	float GetAudibility(FISoundChannel *chan);
+
+	// Synchronizes following sound startups.
+	void Sync (bool sync);
+
+	// Pauses or resumes all sound effect channels.
+	void SetSfxPaused (bool paused, int slot);
+
+	// Pauses or resumes *every* channel, including environmental reverb.
+	void SetInactive (EInactiveState inactive);
+
+	// Updates the position of a sound channel.
+	void UpdateSoundParams3D (SoundListener *listener, FISoundChannel *chan, bool areasound, const FVector3 &pos, const FVector3 &vel);
+
+	void UpdateListener (SoundListener *listener);
+	void UpdateSounds ();
+
+	void PrintStatus ();
+	void PrintDriversList ();
+	FString GatherStats ();
+	short *DecodeSample(int outlen, const void *coded, int sizebytes, ECodecType type);
+
+	void DrawWaveDebug(int mode);
+
+private:
+	DWORD ActiveFMODVersion;
+	int SFXPaused;
+	bool InitSuccess;
+	bool DSPLocked;
+	QWORD_UNION DSPClock;
+	int OutputRate;
+
+	static FMOD_RESULT F_CALLBACK ChannelCallback(FMOD_CHANNELCONTROL *channel, FMOD_CHANNELCONTROL_TYPE controltype, FMOD_CHANNELCONTROL_CALLBACK_TYPE callbacktype,void *data1, void *data2);
+	static float F_CALLBACK RolloffCallback(FMOD_CHANNELCONTROL *channel, float distance);
+
+	bool HandleChannelDelay(FMOD::Channel *chan, FISoundChannel *reuse_chan, int flags, float freq) const;
+	FISoundChannel *CommonChannelSetup(FMOD::Channel *chan, FISoundChannel *reuse_chan) const;
+	FMOD_MODE SetChanHeadSettings(SoundListener *listener, FMOD::Channel *chan, const FVector3 &pos, bool areasound, FMOD_MODE oldmode) const;
+
+	bool ReconnectSFXReverbUnit();
+	void InitCreateSoundExInfo(FMOD_CREATESOUNDEXINFO *exinfo) const;
+	FMOD_RESULT SetSystemReverbProperties(const REVERB_PROPERTIES *props);
+
+	bool Init ();
+	void Shutdown ();
+#ifndef NO_FMOD_CAPS_FIX_ME
+	void DumpDriverCaps(FMOD_CAPS caps, int minfrequency, int maxfrequency);
+#endif
+	int DrawChannelGroupOutput(FMOD::ChannelGroup *group, float *wavearray, int width, int height, int y, int mode);
+	int DrawSystemOutput(float *wavearray, int width, int height, int y, int mode);
+
+	int DrawChannelGroupWaveData(FMOD::ChannelGroup *group, float *wavearray, int width, int height, int y, bool skip);
+	int DrawSystemWaveData(float *wavearray, int width, int height, int y, bool skip);
+	void DrawWave(float *wavearray, int x, int y, int width, int height);
+
+	int DrawChannelGroupSpectrum(FMOD::ChannelGroup *group, float *wavearray, int width, int height, int y, bool skip);
+	int DrawSystemSpectrum(float *wavearray, int width, int height, int y, bool skip);
+	void DrawSpectrum(float *spectrumarray, int x, int y, int width, int height);
+
+	typedef char spk[4];
+	static const spk SpeakerNames4[4], SpeakerNamesMore[8];
+	void DrawSpeakerLabels(const spk *labels, int y, int width, int count);
+
+	FMOD::System *Sys;
+	FMOD::ChannelGroup *SfxGroup, *PausableSfx;
+	FMOD::ChannelGroup *MusicGroup;
+	FMOD::DSP *WaterLP, *WaterReverb;
+	FMOD::DSPConnection *SfxConnection;
+	FMOD::DSPConnection *ChannelGroupTargetUnitOutput;
+	FMOD::DSP *ChannelGroupTargetUnit;
+	FMOD::DSP *SfxReverbPlaceholder;
+	bool SfxReverbHooked;
+	float LastWaterLP;
+	unsigned int OutputPlugin;
+#ifndef NO_FMOD_CAPS_FIX_ME
+	// Just for snd_status display
+	int Driver_MinFrequency;
+	int Driver_MaxFrequency;
+	FMOD_CAPS Driver_Caps;
+#endif
+	friend class FMODStreamCapsule;
+};
+
+#endif
+#endif
diff --git a/src/v_video.cpp b/src/v_video.cpp
index b9eff80..aef5fd5 100644
--- a/src/v_video.cpp
+++ b/src/v_video.cpp
@@ -1601,6 +1601,7 @@ void V_Init2()
 
 	I_InitGraphics();
 	I_ClosestResolution (&width, &height, 8);
+
     
 	if (!Video->SetResolution (width, height, 8))
 		I_FatalError ("Could not set resolution to %d x %d x %d", width, height, 8);
-- 
2.5.4 (Apple Git-61)

